{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar utils = require('./utils');\nvar sasl = require('./sasl');\nvar pgPass = require('pgpass');\nvar TypeOverrides = require('./type-overrides');\nvar ConnectionParameters = require('./connection-parameters');\nvar Query = require('./query');\nvar defaults = require('./defaults');\nvar Connection = require('./connection');\nclass Client extends EventEmitter {\n  constructor(config) {\n    super();\n    this.connectionParameters = new ConnectionParameters(config);\n    this.user = this.connectionParameters.user;\n    this.database = this.connectionParameters.database;\n    this.port = this.connectionParameters.port;\n    this.host = this.connectionParameters.host;\n\n    // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n    Object.defineProperty(this, 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: this.connectionParameters.password\n    });\n    this.replication = this.connectionParameters.replication;\n    var c = config || {};\n    this._Promise = c.Promise || global.Promise;\n    this._types = new TypeOverrides(c.types);\n    this._ending = false;\n    this._connecting = false;\n    this._connected = false;\n    this._connectionError = false;\n    this._queryable = true;\n    this.connection = c.connection || new Connection({\n      stream: c.stream,\n      ssl: this.connectionParameters.ssl,\n      keepAlive: c.keepAlive || false,\n      keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n      encoding: this.connectionParameters.client_encoding || 'utf8'\n    });\n    this.queryQueue = [];\n    this.binary = c.binary || defaults.binary;\n    this.processID = null;\n    this.secretKey = null;\n    this.ssl = this.connectionParameters.ssl || false;\n    // As with Password, make SSL->Key (the private key) non-enumerable.\n    // It won't show up in stack traces\n    // or if the client is console.logged\n    if (this.ssl && this.ssl.key) {\n      Object.defineProperty(this.ssl, 'key', {\n        enumerable: false\n      });\n    }\n    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;\n  }\n  _errorAllQueries(err) {\n    const enqueueError = query => {\n      process.nextTick(() => {\n        query.handleError(err, this.connection);\n      });\n    };\n    if (this.activeQuery) {\n      enqueueError(this.activeQuery);\n      this.activeQuery = null;\n    }\n    this.queryQueue.forEach(enqueueError);\n    this.queryQueue.length = 0;\n  }\n  _connect(callback) {\n    var self = this;\n    var con = this.connection;\n    this._connectionCallback = callback;\n    if (this._connecting || this._connected) {\n      const err = new Error('Client has already been connected. You cannot reuse a client.');\n      process.nextTick(() => {\n        callback(err);\n      });\n      return;\n    }\n    this._connecting = true;\n    this.connectionTimeoutHandle;\n    if (this._connectionTimeoutMillis > 0) {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        con._ending = true;\n        con.stream.destroy(new Error('timeout expired'));\n      }, this._connectionTimeoutMillis);\n    }\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port);\n    } else {\n      con.connect(this.port, this.host);\n    }\n\n    // once connection is established send startup message\n    con.on('connect', function () {\n      if (self.ssl) {\n        con.requestSsl();\n      } else {\n        con.startup(self.getStartupConf());\n      }\n    });\n    con.on('sslconnect', function () {\n      con.startup(self.getStartupConf());\n    });\n    this._attachListeners(con);\n    con.once('end', () => {\n      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly');\n      clearTimeout(this.connectionTimeoutHandle);\n      this._errorAllQueries(error);\n      if (!this._ending) {\n        // if the connection is ended without us calling .end()\n        // on this client then we have an unexpected disconnection\n        // treat this as an error unless we've already emitted an error\n        // during connection.\n        if (this._connecting && !this._connectionError) {\n          if (this._connectionCallback) {\n            this._connectionCallback(error);\n          } else {\n            this._handleErrorEvent(error);\n          }\n        } else if (!this._connectionError) {\n          this._handleErrorEvent(error);\n        }\n      }\n      process.nextTick(() => {\n        this.emit('end');\n      });\n    });\n  }\n  connect(callback) {\n    if (callback) {\n      this._connect(callback);\n      return;\n    }\n    return new this._Promise((resolve, reject) => {\n      this._connect(error => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  _attachListeners(con) {\n    // password request handling\n    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this));\n    // password request handling\n    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this));\n    // password request handling (SASL)\n    con.on('authenticationSASL', this._handleAuthSASL.bind(this));\n    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this));\n    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this));\n    con.on('backendKeyData', this._handleBackendKeyData.bind(this));\n    con.on('error', this._handleErrorEvent.bind(this));\n    con.on('errorMessage', this._handleErrorMessage.bind(this));\n    con.on('readyForQuery', this._handleReadyForQuery.bind(this));\n    con.on('notice', this._handleNotice.bind(this));\n    con.on('rowDescription', this._handleRowDescription.bind(this));\n    con.on('dataRow', this._handleDataRow.bind(this));\n    con.on('portalSuspended', this._handlePortalSuspended.bind(this));\n    con.on('emptyQuery', this._handleEmptyQuery.bind(this));\n    con.on('commandComplete', this._handleCommandComplete.bind(this));\n    con.on('parseComplete', this._handleParseComplete.bind(this));\n    con.on('copyInResponse', this._handleCopyInResponse.bind(this));\n    con.on('copyData', this._handleCopyData.bind(this));\n    con.on('notification', this._handleNotification.bind(this));\n  }\n\n  // TODO(bmc): deprecate pgpass \"built in\" integration since this.password can be a function\n  // it can be supplied by the user if required - this is a breaking change!\n  _checkPgPass(cb) {\n    const con = this.connection;\n    if (typeof this.password === 'function') {\n      this._Promise.resolve().then(() => this.password()).then(pass => {\n        if (pass !== undefined) {\n          if (typeof pass !== 'string') {\n            con.emit('error', new TypeError('Password must be a string'));\n            return;\n          }\n          this.connectionParameters.password = this.password = pass;\n        } else {\n          this.connectionParameters.password = this.password = null;\n        }\n        cb();\n      }).catch(err => {\n        con.emit('error', err);\n      });\n    } else if (this.password !== null) {\n      cb();\n    } else {\n      pgPass(this.connectionParameters, pass => {\n        if (undefined !== pass) {\n          this.connectionParameters.password = this.password = pass;\n        }\n        cb();\n      });\n    }\n  }\n  _handleAuthCleartextPassword(msg) {\n    this._checkPgPass(() => {\n      this.connection.password(this.password);\n    });\n  }\n  _handleAuthMD5Password(msg) {\n    this._checkPgPass(() => {\n      const hashedPassword = utils.postgresMd5PasswordHash(this.user, this.password, msg.salt);\n      this.connection.password(hashedPassword);\n    });\n  }\n  _handleAuthSASL(msg) {\n    this._checkPgPass(() => {\n      try {\n        this.saslSession = sasl.startSession(msg.mechanisms);\n        this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);\n      } catch (err) {\n        this.connection.emit('error', err);\n      }\n    });\n  }\n  _handleAuthSASLContinue(msg) {\n    try {\n      sasl.continueSession(this.saslSession, this.password, msg.data);\n      this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);\n    } catch (err) {\n      this.connection.emit('error', err);\n    }\n  }\n  _handleAuthSASLFinal(msg) {\n    try {\n      sasl.finalizeSession(this.saslSession, msg.data);\n      this.saslSession = null;\n    } catch (err) {\n      this.connection.emit('error', err);\n    }\n  }\n  _handleBackendKeyData(msg) {\n    this.processID = msg.processID;\n    this.secretKey = msg.secretKey;\n  }\n  _handleReadyForQuery(msg) {\n    if (this._connecting) {\n      this._connecting = false;\n      this._connected = true;\n      clearTimeout(this.connectionTimeoutHandle);\n\n      // process possible callback argument to Client#connect\n      if (this._connectionCallback) {\n        this._connectionCallback(null, this);\n        // remove callback for proper error handling\n        // after the connect event\n        this._connectionCallback = null;\n      }\n      this.emit('connect');\n    }\n    const {\n      activeQuery\n    } = this;\n    this.activeQuery = null;\n    this.readyForQuery = true;\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(this.connection);\n    }\n    this._pulseQueryQueue();\n  }\n\n  // if we receieve an error event or error message\n  // during the connection process we handle it here\n  _handleErrorWhileConnecting(err) {\n    if (this._connectionError) {\n      // TODO(bmc): this is swallowing errors - we shouldn't do this\n      return;\n    }\n    this._connectionError = true;\n    clearTimeout(this.connectionTimeoutHandle);\n    if (this._connectionCallback) {\n      return this._connectionCallback(err);\n    }\n    this.emit('error', err);\n  }\n\n  // if we're connected and we receive an error event from the connection\n  // this means the socket is dead - do a hard abort of all queries and emit\n  // the socket error on the client as well\n  _handleErrorEvent(err) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(err);\n    }\n    this._queryable = false;\n    this._errorAllQueries(err);\n    this.emit('error', err);\n  }\n\n  // handle error messages from the postgres backend\n  _handleErrorMessage(msg) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(msg);\n    }\n    const activeQuery = this.activeQuery;\n    if (!activeQuery) {\n      this._handleErrorEvent(msg);\n      return;\n    }\n    this.activeQuery = null;\n    activeQuery.handleError(msg, this.connection);\n  }\n  _handleRowDescription(msg) {\n    // delegate rowDescription to active query\n    this.activeQuery.handleRowDescription(msg);\n  }\n  _handleDataRow(msg) {\n    // delegate dataRow to active query\n    this.activeQuery.handleDataRow(msg);\n  }\n  _handlePortalSuspended(msg) {\n    // delegate portalSuspended to active query\n    this.activeQuery.handlePortalSuspended(this.connection);\n  }\n  _handleEmptyQuery(msg) {\n    // delegate emptyQuery to active query\n    this.activeQuery.handleEmptyQuery(this.connection);\n  }\n  _handleCommandComplete(msg) {\n    // delegate commandComplete to active query\n    this.activeQuery.handleCommandComplete(msg, this.connection);\n  }\n  _handleParseComplete(msg) {\n    // if a prepared statement has a name and properly parses\n    // we track that its already been executed so we don't parse\n    // it again on the same client\n    if (this.activeQuery.name) {\n      this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;\n    }\n  }\n  _handleCopyInResponse(msg) {\n    this.activeQuery.handleCopyInResponse(this.connection);\n  }\n  _handleCopyData(msg) {\n    this.activeQuery.handleCopyData(msg, this.connection);\n  }\n  _handleNotification(msg) {\n    this.emit('notification', msg);\n  }\n  _handleNotice(msg) {\n    this.emit('notice', msg);\n  }\n  getStartupConf() {\n    var params = this.connectionParameters;\n    var data = {\n      user: params.user,\n      database: params.database\n    };\n    var appName = params.application_name || params.fallback_application_name;\n    if (appName) {\n      data.application_name = appName;\n    }\n    if (params.replication) {\n      data.replication = '' + params.replication;\n    }\n    if (params.statement_timeout) {\n      data.statement_timeout = String(parseInt(params.statement_timeout, 10));\n    }\n    if (params.lock_timeout) {\n      data.lock_timeout = String(parseInt(params.lock_timeout, 10));\n    }\n    if (params.idle_in_transaction_session_timeout) {\n      data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));\n    }\n    if (params.options) {\n      data.options = params.options;\n    }\n    return data;\n  }\n  cancel(client, query) {\n    if (client.activeQuery === query) {\n      var con = this.connection;\n      if (this.host && this.host.indexOf('/') === 0) {\n        con.connect(this.host + '/.s.PGSQL.' + this.port);\n      } else {\n        con.connect(this.port, this.host);\n      }\n\n      // once connection is established send cancel message\n      con.on('connect', function () {\n        con.cancel(client.processID, client.secretKey);\n      });\n    } else if (client.queryQueue.indexOf(query) !== -1) {\n      client.queryQueue.splice(client.queryQueue.indexOf(query), 1);\n    }\n  }\n  setTypeParser(oid, format, parseFn) {\n    return this._types.setTypeParser(oid, format, parseFn);\n  }\n  getTypeParser(oid, format) {\n    return this._types.getTypeParser(oid, format);\n  }\n\n  // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n  escapeIdentifier(str) {\n    return '\"' + str.replace(/\"/g, '\"\"') + '\"';\n  }\n\n  // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n  escapeLiteral(str) {\n    var hasBackslash = false;\n    var escaped = \"'\";\n    for (var i = 0; i < str.length; i++) {\n      var c = str[i];\n      if (c === \"'\") {\n        escaped += c + c;\n      } else if (c === '\\\\') {\n        escaped += c + c;\n        hasBackslash = true;\n      } else {\n        escaped += c;\n      }\n    }\n    escaped += \"'\";\n    if (hasBackslash === true) {\n      escaped = ' E' + escaped;\n    }\n    return escaped;\n  }\n  _pulseQueryQueue() {\n    if (this.readyForQuery === true) {\n      this.activeQuery = this.queryQueue.shift();\n      if (this.activeQuery) {\n        this.readyForQuery = false;\n        this.hasExecuted = true;\n        const queryError = this.activeQuery.submit(this.connection);\n        if (queryError) {\n          process.nextTick(() => {\n            this.activeQuery.handleError(queryError, this.connection);\n            this.readyForQuery = true;\n            this._pulseQueryQueue();\n          });\n        }\n      } else if (this.hasExecuted) {\n        this.activeQuery = null;\n        this.emit('drain');\n      }\n    }\n  }\n  query(config, values, callback) {\n    // can take in strings, config object or query object\n    var query;\n    var result;\n    var readTimeout;\n    var readTimeoutTimer;\n    var queryCallback;\n    if (config === null || config === undefined) {\n      throw new TypeError('Client was passed a null or undefined query');\n    } else if (typeof config.submit === 'function') {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;\n      result = query = config;\n      if (typeof values === 'function') {\n        query.callback = query.callback || values;\n      }\n    } else {\n      readTimeout = this.connectionParameters.query_timeout;\n      query = new Query(config, values, callback);\n      if (!query.callback) {\n        result = new this._Promise((resolve, reject) => {\n          query.callback = (err, res) => err ? reject(err) : resolve(res);\n        });\n      }\n    }\n    if (readTimeout) {\n      queryCallback = query.callback;\n      readTimeoutTimer = setTimeout(() => {\n        var error = new Error('Query read timeout');\n        process.nextTick(() => {\n          query.handleError(error, this.connection);\n        });\n        queryCallback(error);\n\n        // we already returned an error,\n        // just do nothing if query completes\n        query.callback = () => {};\n\n        // Remove from queue\n        var index = this.queryQueue.indexOf(query);\n        if (index > -1) {\n          this.queryQueue.splice(index, 1);\n        }\n        this._pulseQueryQueue();\n      }, readTimeout);\n      query.callback = (err, res) => {\n        clearTimeout(readTimeoutTimer);\n        queryCallback(err, res);\n      };\n    }\n    if (this.binary && !query.binary) {\n      query.binary = true;\n    }\n    if (query._result && !query._result._types) {\n      query._result._types = this._types;\n    }\n    if (!this._queryable) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection);\n      });\n      return result;\n    }\n    if (this._ending) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client was closed and is not queryable'), this.connection);\n      });\n      return result;\n    }\n    this.queryQueue.push(query);\n    this._pulseQueryQueue();\n    return result;\n  }\n  ref() {\n    this.connection.ref();\n  }\n  unref() {\n    this.connection.unref();\n  }\n  end(cb) {\n    this._ending = true;\n\n    // if we have never connected, then end is a noop, callback immediately\n    if (!this.connection._connecting) {\n      if (cb) {\n        cb();\n      } else {\n        return this._Promise.resolve();\n      }\n    }\n    if (this.activeQuery || !this._queryable) {\n      // if we have an active query we need to force a disconnect\n      // on the socket - otherwise a hung query could block end forever\n      this.connection.stream.destroy();\n    } else {\n      this.connection.end();\n    }\n    if (cb) {\n      this.connection.once('end', cb);\n    } else {\n      return new this._Promise(resolve => {\n        this.connection.once('end', resolve);\n      });\n    }\n  }\n}\n\n// expose a Query constructor\nClient.Query = Query;\nmodule.exports = Client;","map":{"version":3,"names":["EventEmitter","require","utils","sasl","pgPass","TypeOverrides","ConnectionParameters","Query","defaults","Connection","Client","constructor","config","connectionParameters","user","database","port","host","Object","defineProperty","configurable","enumerable","writable","value","password","replication","c","_Promise","Promise","global","_types","types","_ending","_connecting","_connected","_connectionError","_queryable","connection","stream","ssl","keepAlive","keepAliveInitialDelayMillis","encoding","client_encoding","queryQueue","binary","processID","secretKey","key","_connectionTimeoutMillis","connectionTimeoutMillis","_errorAllQueries","err","enqueueError","query","process","nextTick","handleError","activeQuery","forEach","length","_connect","callback","self","con","_connectionCallback","Error","connectionTimeoutHandle","setTimeout","destroy","indexOf","connect","on","requestSsl","startup","getStartupConf","_attachListeners","once","error","clearTimeout","_handleErrorEvent","emit","resolve","reject","_handleAuthCleartextPassword","bind","_handleAuthMD5Password","_handleAuthSASL","_handleAuthSASLContinue","_handleAuthSASLFinal","_handleBackendKeyData","_handleErrorMessage","_handleReadyForQuery","_handleNotice","_handleRowDescription","_handleDataRow","_handlePortalSuspended","_handleEmptyQuery","_handleCommandComplete","_handleParseComplete","_handleCopyInResponse","_handleCopyData","_handleNotification","_checkPgPass","cb","then","pass","undefined","TypeError","catch","msg","hashedPassword","postgresMd5PasswordHash","salt","saslSession","startSession","mechanisms","sendSASLInitialResponseMessage","mechanism","response","continueSession","data","sendSCRAMClientFinalMessage","finalizeSession","readyForQuery","handleReadyForQuery","_pulseQueryQueue","_handleErrorWhileConnecting","handleRowDescription","handleDataRow","handlePortalSuspended","handleEmptyQuery","handleCommandComplete","name","parsedStatements","text","handleCopyInResponse","handleCopyData","params","appName","application_name","fallback_application_name","statement_timeout","String","parseInt","lock_timeout","idle_in_transaction_session_timeout","options","cancel","client","splice","setTypeParser","oid","format","parseFn","getTypeParser","escapeIdentifier","str","replace","escapeLiteral","hasBackslash","escaped","i","shift","hasExecuted","queryError","submit","values","result","readTimeout","readTimeoutTimer","queryCallback","query_timeout","res","index","_result","push","ref","unref","end","module","exports"],"sources":["C:/Users/Kamen/ML/AlgoTrader/node_modules/pg/lib/client.js"],"sourcesContent":["'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar utils = require('./utils')\nvar sasl = require('./sasl')\nvar pgPass = require('pgpass')\nvar TypeOverrides = require('./type-overrides')\n\nvar ConnectionParameters = require('./connection-parameters')\nvar Query = require('./query')\nvar defaults = require('./defaults')\nvar Connection = require('./connection')\n\nclass Client extends EventEmitter {\n  constructor(config) {\n    super()\n\n    this.connectionParameters = new ConnectionParameters(config)\n    this.user = this.connectionParameters.user\n    this.database = this.connectionParameters.database\n    this.port = this.connectionParameters.port\n    this.host = this.connectionParameters.host\n\n    // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n    Object.defineProperty(this, 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: this.connectionParameters.password,\n    })\n\n    this.replication = this.connectionParameters.replication\n\n    var c = config || {}\n\n    this._Promise = c.Promise || global.Promise\n    this._types = new TypeOverrides(c.types)\n    this._ending = false\n    this._connecting = false\n    this._connected = false\n    this._connectionError = false\n    this._queryable = true\n\n    this.connection =\n      c.connection ||\n      new Connection({\n        stream: c.stream,\n        ssl: this.connectionParameters.ssl,\n        keepAlive: c.keepAlive || false,\n        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n        encoding: this.connectionParameters.client_encoding || 'utf8',\n      })\n    this.queryQueue = []\n    this.binary = c.binary || defaults.binary\n    this.processID = null\n    this.secretKey = null\n    this.ssl = this.connectionParameters.ssl || false\n    // As with Password, make SSL->Key (the private key) non-enumerable.\n    // It won't show up in stack traces\n    // or if the client is console.logged\n    if (this.ssl && this.ssl.key) {\n      Object.defineProperty(this.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0\n  }\n\n  _errorAllQueries(err) {\n    const enqueueError = (query) => {\n      process.nextTick(() => {\n        query.handleError(err, this.connection)\n      })\n    }\n\n    if (this.activeQuery) {\n      enqueueError(this.activeQuery)\n      this.activeQuery = null\n    }\n\n    this.queryQueue.forEach(enqueueError)\n    this.queryQueue.length = 0\n  }\n\n  _connect(callback) {\n    var self = this\n    var con = this.connection\n    this._connectionCallback = callback\n\n    if (this._connecting || this._connected) {\n      const err = new Error('Client has already been connected. You cannot reuse a client.')\n      process.nextTick(() => {\n        callback(err)\n      })\n      return\n    }\n    this._connecting = true\n\n    this.connectionTimeoutHandle\n    if (this._connectionTimeoutMillis > 0) {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        con._ending = true\n        con.stream.destroy(new Error('timeout expired'))\n      }, this._connectionTimeoutMillis)\n    }\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port)\n    } else {\n      con.connect(this.port, this.host)\n    }\n\n    // once connection is established send startup message\n    con.on('connect', function () {\n      if (self.ssl) {\n        con.requestSsl()\n      } else {\n        con.startup(self.getStartupConf())\n      }\n    })\n\n    con.on('sslconnect', function () {\n      con.startup(self.getStartupConf())\n    })\n\n    this._attachListeners(con)\n\n    con.once('end', () => {\n      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly')\n\n      clearTimeout(this.connectionTimeoutHandle)\n      this._errorAllQueries(error)\n\n      if (!this._ending) {\n        // if the connection is ended without us calling .end()\n        // on this client then we have an unexpected disconnection\n        // treat this as an error unless we've already emitted an error\n        // during connection.\n        if (this._connecting && !this._connectionError) {\n          if (this._connectionCallback) {\n            this._connectionCallback(error)\n          } else {\n            this._handleErrorEvent(error)\n          }\n        } else if (!this._connectionError) {\n          this._handleErrorEvent(error)\n        }\n      }\n\n      process.nextTick(() => {\n        this.emit('end')\n      })\n    })\n  }\n\n  connect(callback) {\n    if (callback) {\n      this._connect(callback)\n      return\n    }\n\n    return new this._Promise((resolve, reject) => {\n      this._connect((error) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  _attachListeners(con) {\n    // password request handling\n    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this))\n    // password request handling\n    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this))\n    // password request handling (SASL)\n    con.on('authenticationSASL', this._handleAuthSASL.bind(this))\n    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this))\n    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this))\n    con.on('backendKeyData', this._handleBackendKeyData.bind(this))\n    con.on('error', this._handleErrorEvent.bind(this))\n    con.on('errorMessage', this._handleErrorMessage.bind(this))\n    con.on('readyForQuery', this._handleReadyForQuery.bind(this))\n    con.on('notice', this._handleNotice.bind(this))\n    con.on('rowDescription', this._handleRowDescription.bind(this))\n    con.on('dataRow', this._handleDataRow.bind(this))\n    con.on('portalSuspended', this._handlePortalSuspended.bind(this))\n    con.on('emptyQuery', this._handleEmptyQuery.bind(this))\n    con.on('commandComplete', this._handleCommandComplete.bind(this))\n    con.on('parseComplete', this._handleParseComplete.bind(this))\n    con.on('copyInResponse', this._handleCopyInResponse.bind(this))\n    con.on('copyData', this._handleCopyData.bind(this))\n    con.on('notification', this._handleNotification.bind(this))\n  }\n\n  // TODO(bmc): deprecate pgpass \"built in\" integration since this.password can be a function\n  // it can be supplied by the user if required - this is a breaking change!\n  _checkPgPass(cb) {\n    const con = this.connection\n    if (typeof this.password === 'function') {\n      this._Promise\n        .resolve()\n        .then(() => this.password())\n        .then((pass) => {\n          if (pass !== undefined) {\n            if (typeof pass !== 'string') {\n              con.emit('error', new TypeError('Password must be a string'))\n              return\n            }\n            this.connectionParameters.password = this.password = pass\n          } else {\n            this.connectionParameters.password = this.password = null\n          }\n          cb()\n        })\n        .catch((err) => {\n          con.emit('error', err)\n        })\n    } else if (this.password !== null) {\n      cb()\n    } else {\n      pgPass(this.connectionParameters, (pass) => {\n        if (undefined !== pass) {\n          this.connectionParameters.password = this.password = pass\n        }\n        cb()\n      })\n    }\n  }\n\n  _handleAuthCleartextPassword(msg) {\n    this._checkPgPass(() => {\n      this.connection.password(this.password)\n    })\n  }\n\n  _handleAuthMD5Password(msg) {\n    this._checkPgPass(() => {\n      const hashedPassword = utils.postgresMd5PasswordHash(this.user, this.password, msg.salt)\n      this.connection.password(hashedPassword)\n    })\n  }\n\n  _handleAuthSASL(msg) {\n    this._checkPgPass(() => {\n      try {\n        this.saslSession = sasl.startSession(msg.mechanisms)\n        this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response)\n      } catch (err) {\n        this.connection.emit('error', err)\n      }\n    })\n  }\n\n  _handleAuthSASLContinue(msg) {\n    try {\n      sasl.continueSession(this.saslSession, this.password, msg.data)\n      this.connection.sendSCRAMClientFinalMessage(this.saslSession.response)\n    } catch (err) {\n      this.connection.emit('error', err)\n    }\n  }\n\n  _handleAuthSASLFinal(msg) {\n    try {\n      sasl.finalizeSession(this.saslSession, msg.data)\n      this.saslSession = null\n    } catch (err) {\n      this.connection.emit('error', err)\n    }\n  }\n\n  _handleBackendKeyData(msg) {\n    this.processID = msg.processID\n    this.secretKey = msg.secretKey\n  }\n\n  _handleReadyForQuery(msg) {\n    if (this._connecting) {\n      this._connecting = false\n      this._connected = true\n      clearTimeout(this.connectionTimeoutHandle)\n\n      // process possible callback argument to Client#connect\n      if (this._connectionCallback) {\n        this._connectionCallback(null, this)\n        // remove callback for proper error handling\n        // after the connect event\n        this._connectionCallback = null\n      }\n      this.emit('connect')\n    }\n    const { activeQuery } = this\n    this.activeQuery = null\n    this.readyForQuery = true\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(this.connection)\n    }\n    this._pulseQueryQueue()\n  }\n\n  // if we receieve an error event or error message\n  // during the connection process we handle it here\n  _handleErrorWhileConnecting(err) {\n    if (this._connectionError) {\n      // TODO(bmc): this is swallowing errors - we shouldn't do this\n      return\n    }\n    this._connectionError = true\n    clearTimeout(this.connectionTimeoutHandle)\n    if (this._connectionCallback) {\n      return this._connectionCallback(err)\n    }\n    this.emit('error', err)\n  }\n\n  // if we're connected and we receive an error event from the connection\n  // this means the socket is dead - do a hard abort of all queries and emit\n  // the socket error on the client as well\n  _handleErrorEvent(err) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(err)\n    }\n    this._queryable = false\n    this._errorAllQueries(err)\n    this.emit('error', err)\n  }\n\n  // handle error messages from the postgres backend\n  _handleErrorMessage(msg) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(msg)\n    }\n    const activeQuery = this.activeQuery\n\n    if (!activeQuery) {\n      this._handleErrorEvent(msg)\n      return\n    }\n\n    this.activeQuery = null\n    activeQuery.handleError(msg, this.connection)\n  }\n\n  _handleRowDescription(msg) {\n    // delegate rowDescription to active query\n    this.activeQuery.handleRowDescription(msg)\n  }\n\n  _handleDataRow(msg) {\n    // delegate dataRow to active query\n    this.activeQuery.handleDataRow(msg)\n  }\n\n  _handlePortalSuspended(msg) {\n    // delegate portalSuspended to active query\n    this.activeQuery.handlePortalSuspended(this.connection)\n  }\n\n  _handleEmptyQuery(msg) {\n    // delegate emptyQuery to active query\n    this.activeQuery.handleEmptyQuery(this.connection)\n  }\n\n  _handleCommandComplete(msg) {\n    // delegate commandComplete to active query\n    this.activeQuery.handleCommandComplete(msg, this.connection)\n  }\n\n  _handleParseComplete(msg) {\n    // if a prepared statement has a name and properly parses\n    // we track that its already been executed so we don't parse\n    // it again on the same client\n    if (this.activeQuery.name) {\n      this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text\n    }\n  }\n\n  _handleCopyInResponse(msg) {\n    this.activeQuery.handleCopyInResponse(this.connection)\n  }\n\n  _handleCopyData(msg) {\n    this.activeQuery.handleCopyData(msg, this.connection)\n  }\n\n  _handleNotification(msg) {\n    this.emit('notification', msg)\n  }\n\n  _handleNotice(msg) {\n    this.emit('notice', msg)\n  }\n\n  getStartupConf() {\n    var params = this.connectionParameters\n\n    var data = {\n      user: params.user,\n      database: params.database,\n    }\n\n    var appName = params.application_name || params.fallback_application_name\n    if (appName) {\n      data.application_name = appName\n    }\n    if (params.replication) {\n      data.replication = '' + params.replication\n    }\n    if (params.statement_timeout) {\n      data.statement_timeout = String(parseInt(params.statement_timeout, 10))\n    }\n    if (params.lock_timeout) {\n      data.lock_timeout = String(parseInt(params.lock_timeout, 10))\n    }\n    if (params.idle_in_transaction_session_timeout) {\n      data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10))\n    }\n    if (params.options) {\n      data.options = params.options\n    }\n\n    return data\n  }\n\n  cancel(client, query) {\n    if (client.activeQuery === query) {\n      var con = this.connection\n\n      if (this.host && this.host.indexOf('/') === 0) {\n        con.connect(this.host + '/.s.PGSQL.' + this.port)\n      } else {\n        con.connect(this.port, this.host)\n      }\n\n      // once connection is established send cancel message\n      con.on('connect', function () {\n        con.cancel(client.processID, client.secretKey)\n      })\n    } else if (client.queryQueue.indexOf(query) !== -1) {\n      client.queryQueue.splice(client.queryQueue.indexOf(query), 1)\n    }\n  }\n\n  setTypeParser(oid, format, parseFn) {\n    return this._types.setTypeParser(oid, format, parseFn)\n  }\n\n  getTypeParser(oid, format) {\n    return this._types.getTypeParser(oid, format)\n  }\n\n  // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n  escapeIdentifier(str) {\n    return '\"' + str.replace(/\"/g, '\"\"') + '\"'\n  }\n\n  // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n  escapeLiteral(str) {\n    var hasBackslash = false\n    var escaped = \"'\"\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str[i]\n      if (c === \"'\") {\n        escaped += c + c\n      } else if (c === '\\\\') {\n        escaped += c + c\n        hasBackslash = true\n      } else {\n        escaped += c\n      }\n    }\n\n    escaped += \"'\"\n\n    if (hasBackslash === true) {\n      escaped = ' E' + escaped\n    }\n\n    return escaped\n  }\n\n  _pulseQueryQueue() {\n    if (this.readyForQuery === true) {\n      this.activeQuery = this.queryQueue.shift()\n      if (this.activeQuery) {\n        this.readyForQuery = false\n        this.hasExecuted = true\n\n        const queryError = this.activeQuery.submit(this.connection)\n        if (queryError) {\n          process.nextTick(() => {\n            this.activeQuery.handleError(queryError, this.connection)\n            this.readyForQuery = true\n            this._pulseQueryQueue()\n          })\n        }\n      } else if (this.hasExecuted) {\n        this.activeQuery = null\n        this.emit('drain')\n      }\n    }\n  }\n\n  query(config, values, callback) {\n    // can take in strings, config object or query object\n    var query\n    var result\n    var readTimeout\n    var readTimeoutTimer\n    var queryCallback\n\n    if (config === null || config === undefined) {\n      throw new TypeError('Client was passed a null or undefined query')\n    } else if (typeof config.submit === 'function') {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n      result = query = config\n      if (typeof values === 'function') {\n        query.callback = query.callback || values\n      }\n    } else {\n      readTimeout = this.connectionParameters.query_timeout\n      query = new Query(config, values, callback)\n      if (!query.callback) {\n        result = new this._Promise((resolve, reject) => {\n          query.callback = (err, res) => (err ? reject(err) : resolve(res))\n        })\n      }\n    }\n\n    if (readTimeout) {\n      queryCallback = query.callback\n\n      readTimeoutTimer = setTimeout(() => {\n        var error = new Error('Query read timeout')\n\n        process.nextTick(() => {\n          query.handleError(error, this.connection)\n        })\n\n        queryCallback(error)\n\n        // we already returned an error,\n        // just do nothing if query completes\n        query.callback = () => {}\n\n        // Remove from queue\n        var index = this.queryQueue.indexOf(query)\n        if (index > -1) {\n          this.queryQueue.splice(index, 1)\n        }\n\n        this._pulseQueryQueue()\n      }, readTimeout)\n\n      query.callback = (err, res) => {\n        clearTimeout(readTimeoutTimer)\n        queryCallback(err, res)\n      }\n    }\n\n    if (this.binary && !query.binary) {\n      query.binary = true\n    }\n\n    if (query._result && !query._result._types) {\n      query._result._types = this._types\n    }\n\n    if (!this._queryable) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection)\n      })\n      return result\n    }\n\n    if (this._ending) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client was closed and is not queryable'), this.connection)\n      })\n      return result\n    }\n\n    this.queryQueue.push(query)\n    this._pulseQueryQueue()\n    return result\n  }\n\n  ref() {\n    this.connection.ref()\n  }\n\n  unref() {\n    this.connection.unref()\n  }\n\n  end(cb) {\n    this._ending = true\n\n    // if we have never connected, then end is a noop, callback immediately\n    if (!this.connection._connecting) {\n      if (cb) {\n        cb()\n      } else {\n        return this._Promise.resolve()\n      }\n    }\n\n    if (this.activeQuery || !this._queryable) {\n      // if we have an active query we need to force a disconnect\n      // on the socket - otherwise a hung query could block end forever\n      this.connection.stream.destroy()\n    } else {\n      this.connection.end()\n    }\n\n    if (cb) {\n      this.connection.once('end', cb)\n    } else {\n      return new this._Promise((resolve) => {\n        this.connection.once('end', resolve)\n      })\n    }\n  }\n}\n\n// expose a Query constructor\nClient.Query = Query\n\nmodule.exports = Client\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,YAAY,GAAGC,OAAO,CAAC,QAAQ,CAAC,CAACD,YAAY;AACjD,IAAIE,KAAK,GAAGD,OAAO,CAAC,SAAS,CAAC;AAC9B,IAAIE,IAAI,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAC5B,IAAIG,MAAM,GAAGH,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAII,aAAa,GAAGJ,OAAO,CAAC,kBAAkB,CAAC;AAE/C,IAAIK,oBAAoB,GAAGL,OAAO,CAAC,yBAAyB,CAAC;AAC7D,IAAIM,KAAK,GAAGN,OAAO,CAAC,SAAS,CAAC;AAC9B,IAAIO,QAAQ,GAAGP,OAAO,CAAC,YAAY,CAAC;AACpC,IAAIQ,UAAU,GAAGR,OAAO,CAAC,cAAc,CAAC;AAExC,MAAMS,MAAM,SAASV,YAAY,CAAC;EAChCW,WAAWA,CAACC,MAAM,EAAE;IAClB,KAAK,EAAE;IAEP,IAAI,CAACC,oBAAoB,GAAG,IAAIP,oBAAoB,CAACM,MAAM,CAAC;IAC5D,IAAI,CAACE,IAAI,GAAG,IAAI,CAACD,oBAAoB,CAACC,IAAI;IAC1C,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACF,oBAAoB,CAACE,QAAQ;IAClD,IAAI,CAACC,IAAI,GAAG,IAAI,CAACH,oBAAoB,CAACG,IAAI;IAC1C,IAAI,CAACC,IAAI,GAAG,IAAI,CAACJ,oBAAoB,CAACI,IAAI;;IAE1C;IACA;IACAC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,UAAU,EAAE;MACtCC,YAAY,EAAE,IAAI;MAClBC,UAAU,EAAE,KAAK;MACjBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,IAAI,CAACV,oBAAoB,CAACW;IACnC,CAAC,CAAC;IAEF,IAAI,CAACC,WAAW,GAAG,IAAI,CAACZ,oBAAoB,CAACY,WAAW;IAExD,IAAIC,CAAC,GAAGd,MAAM,IAAI,CAAC,CAAC;IAEpB,IAAI,CAACe,QAAQ,GAAGD,CAAC,CAACE,OAAO,IAAIC,MAAM,CAACD,OAAO;IAC3C,IAAI,CAACE,MAAM,GAAG,IAAIzB,aAAa,CAACqB,CAAC,CAACK,KAAK,CAAC;IACxC,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACC,UAAU,GAAG,IAAI;IAEtB,IAAI,CAACC,UAAU,GACbX,CAAC,CAACW,UAAU,IACZ,IAAI5B,UAAU,CAAC;MACb6B,MAAM,EAAEZ,CAAC,CAACY,MAAM;MAChBC,GAAG,EAAE,IAAI,CAAC1B,oBAAoB,CAAC0B,GAAG;MAClCC,SAAS,EAAEd,CAAC,CAACc,SAAS,IAAI,KAAK;MAC/BC,2BAA2B,EAAEf,CAAC,CAACe,2BAA2B,IAAI,CAAC;MAC/DC,QAAQ,EAAE,IAAI,CAAC7B,oBAAoB,CAAC8B,eAAe,IAAI;IACzD,CAAC,CAAC;IACJ,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,MAAM,GAAGnB,CAAC,CAACmB,MAAM,IAAIrC,QAAQ,CAACqC,MAAM;IACzC,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACR,GAAG,GAAG,IAAI,CAAC1B,oBAAoB,CAAC0B,GAAG,IAAI,KAAK;IACjD;IACA;IACA;IACA,IAAI,IAAI,CAACA,GAAG,IAAI,IAAI,CAACA,GAAG,CAACS,GAAG,EAAE;MAC5B9B,MAAM,CAACC,cAAc,CAAC,IAAI,CAACoB,GAAG,EAAE,KAAK,EAAE;QACrClB,UAAU,EAAE;MACd,CAAC,CAAC;IACJ;IAEA,IAAI,CAAC4B,wBAAwB,GAAGvB,CAAC,CAACwB,uBAAuB,IAAI,CAAC;EAChE;EAEAC,gBAAgBA,CAACC,GAAG,EAAE;IACpB,MAAMC,YAAY,GAAIC,KAAK,IAAK;MAC9BC,OAAO,CAACC,QAAQ,CAAC,MAAM;QACrBF,KAAK,CAACG,WAAW,CAACL,GAAG,EAAE,IAAI,CAACf,UAAU,CAAC;MACzC,CAAC,CAAC;IACJ,CAAC;IAED,IAAI,IAAI,CAACqB,WAAW,EAAE;MACpBL,YAAY,CAAC,IAAI,CAACK,WAAW,CAAC;MAC9B,IAAI,CAACA,WAAW,GAAG,IAAI;IACzB;IAEA,IAAI,CAACd,UAAU,CAACe,OAAO,CAACN,YAAY,CAAC;IACrC,IAAI,CAACT,UAAU,CAACgB,MAAM,GAAG,CAAC;EAC5B;EAEAC,QAAQA,CAACC,QAAQ,EAAE;IACjB,IAAIC,IAAI,GAAG,IAAI;IACf,IAAIC,GAAG,GAAG,IAAI,CAAC3B,UAAU;IACzB,IAAI,CAAC4B,mBAAmB,GAAGH,QAAQ;IAEnC,IAAI,IAAI,CAAC7B,WAAW,IAAI,IAAI,CAACC,UAAU,EAAE;MACvC,MAAMkB,GAAG,GAAG,IAAIc,KAAK,CAAC,+DAA+D,CAAC;MACtFX,OAAO,CAACC,QAAQ,CAAC,MAAM;QACrBM,QAAQ,CAACV,GAAG,CAAC;MACf,CAAC,CAAC;MACF;IACF;IACA,IAAI,CAACnB,WAAW,GAAG,IAAI;IAEvB,IAAI,CAACkC,uBAAuB;IAC5B,IAAI,IAAI,CAAClB,wBAAwB,GAAG,CAAC,EAAE;MACrC,IAAI,CAACkB,uBAAuB,GAAGC,UAAU,CAAC,MAAM;QAC9CJ,GAAG,CAAChC,OAAO,GAAG,IAAI;QAClBgC,GAAG,CAAC1B,MAAM,CAAC+B,OAAO,CAAC,IAAIH,KAAK,CAAC,iBAAiB,CAAC,CAAC;MAClD,CAAC,EAAE,IAAI,CAACjB,wBAAwB,CAAC;IACnC;IAEA,IAAI,IAAI,CAAChC,IAAI,IAAI,IAAI,CAACA,IAAI,CAACqD,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;MAC7CN,GAAG,CAACO,OAAO,CAAC,IAAI,CAACtD,IAAI,GAAG,YAAY,GAAG,IAAI,CAACD,IAAI,CAAC;IACnD,CAAC,MAAM;MACLgD,GAAG,CAACO,OAAO,CAAC,IAAI,CAACvD,IAAI,EAAE,IAAI,CAACC,IAAI,CAAC;IACnC;;IAEA;IACA+C,GAAG,CAACQ,EAAE,CAAC,SAAS,EAAE,YAAY;MAC5B,IAAIT,IAAI,CAACxB,GAAG,EAAE;QACZyB,GAAG,CAACS,UAAU,EAAE;MAClB,CAAC,MAAM;QACLT,GAAG,CAACU,OAAO,CAACX,IAAI,CAACY,cAAc,EAAE,CAAC;MACpC;IACF,CAAC,CAAC;IAEFX,GAAG,CAACQ,EAAE,CAAC,YAAY,EAAE,YAAY;MAC/BR,GAAG,CAACU,OAAO,CAACX,IAAI,CAACY,cAAc,EAAE,CAAC;IACpC,CAAC,CAAC;IAEF,IAAI,CAACC,gBAAgB,CAACZ,GAAG,CAAC;IAE1BA,GAAG,CAACa,IAAI,CAAC,KAAK,EAAE,MAAM;MACpB,MAAMC,KAAK,GAAG,IAAI,CAAC9C,OAAO,GAAG,IAAIkC,KAAK,CAAC,uBAAuB,CAAC,GAAG,IAAIA,KAAK,CAAC,oCAAoC,CAAC;MAEjHa,YAAY,CAAC,IAAI,CAACZ,uBAAuB,CAAC;MAC1C,IAAI,CAAChB,gBAAgB,CAAC2B,KAAK,CAAC;MAE5B,IAAI,CAAC,IAAI,CAAC9C,OAAO,EAAE;QACjB;QACA;QACA;QACA;QACA,IAAI,IAAI,CAACC,WAAW,IAAI,CAAC,IAAI,CAACE,gBAAgB,EAAE;UAC9C,IAAI,IAAI,CAAC8B,mBAAmB,EAAE;YAC5B,IAAI,CAACA,mBAAmB,CAACa,KAAK,CAAC;UACjC,CAAC,MAAM;YACL,IAAI,CAACE,iBAAiB,CAACF,KAAK,CAAC;UAC/B;QACF,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC3C,gBAAgB,EAAE;UACjC,IAAI,CAAC6C,iBAAiB,CAACF,KAAK,CAAC;QAC/B;MACF;MAEAvB,OAAO,CAACC,QAAQ,CAAC,MAAM;QACrB,IAAI,CAACyB,IAAI,CAAC,KAAK,CAAC;MAClB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEAV,OAAOA,CAACT,QAAQ,EAAE;IAChB,IAAIA,QAAQ,EAAE;MACZ,IAAI,CAACD,QAAQ,CAACC,QAAQ,CAAC;MACvB;IACF;IAEA,OAAO,IAAI,IAAI,CAACnC,QAAQ,CAAC,CAACuD,OAAO,EAAEC,MAAM,KAAK;MAC5C,IAAI,CAACtB,QAAQ,CAAEiB,KAAK,IAAK;QACvB,IAAIA,KAAK,EAAE;UACTK,MAAM,CAACL,KAAK,CAAC;QACf,CAAC,MAAM;UACLI,OAAO,EAAE;QACX;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEAN,gBAAgBA,CAACZ,GAAG,EAAE;IACpB;IACAA,GAAG,CAACQ,EAAE,CAAC,iCAAiC,EAAE,IAAI,CAACY,4BAA4B,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IACvF;IACArB,GAAG,CAACQ,EAAE,CAAC,2BAA2B,EAAE,IAAI,CAACc,sBAAsB,CAACD,IAAI,CAAC,IAAI,CAAC,CAAC;IAC3E;IACArB,GAAG,CAACQ,EAAE,CAAC,oBAAoB,EAAE,IAAI,CAACe,eAAe,CAACF,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7DrB,GAAG,CAACQ,EAAE,CAAC,4BAA4B,EAAE,IAAI,CAACgB,uBAAuB,CAACH,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7ErB,GAAG,CAACQ,EAAE,CAAC,yBAAyB,EAAE,IAAI,CAACiB,oBAAoB,CAACJ,IAAI,CAAC,IAAI,CAAC,CAAC;IACvErB,GAAG,CAACQ,EAAE,CAAC,gBAAgB,EAAE,IAAI,CAACkB,qBAAqB,CAACL,IAAI,CAAC,IAAI,CAAC,CAAC;IAC/DrB,GAAG,CAACQ,EAAE,CAAC,OAAO,EAAE,IAAI,CAACQ,iBAAiB,CAACK,IAAI,CAAC,IAAI,CAAC,CAAC;IAClDrB,GAAG,CAACQ,EAAE,CAAC,cAAc,EAAE,IAAI,CAACmB,mBAAmB,CAACN,IAAI,CAAC,IAAI,CAAC,CAAC;IAC3DrB,GAAG,CAACQ,EAAE,CAAC,eAAe,EAAE,IAAI,CAACoB,oBAAoB,CAACP,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7DrB,GAAG,CAACQ,EAAE,CAAC,QAAQ,EAAE,IAAI,CAACqB,aAAa,CAACR,IAAI,CAAC,IAAI,CAAC,CAAC;IAC/CrB,GAAG,CAACQ,EAAE,CAAC,gBAAgB,EAAE,IAAI,CAACsB,qBAAqB,CAACT,IAAI,CAAC,IAAI,CAAC,CAAC;IAC/DrB,GAAG,CAACQ,EAAE,CAAC,SAAS,EAAE,IAAI,CAACuB,cAAc,CAACV,IAAI,CAAC,IAAI,CAAC,CAAC;IACjDrB,GAAG,CAACQ,EAAE,CAAC,iBAAiB,EAAE,IAAI,CAACwB,sBAAsB,CAACX,IAAI,CAAC,IAAI,CAAC,CAAC;IACjErB,GAAG,CAACQ,EAAE,CAAC,YAAY,EAAE,IAAI,CAACyB,iBAAiB,CAACZ,IAAI,CAAC,IAAI,CAAC,CAAC;IACvDrB,GAAG,CAACQ,EAAE,CAAC,iBAAiB,EAAE,IAAI,CAAC0B,sBAAsB,CAACb,IAAI,CAAC,IAAI,CAAC,CAAC;IACjErB,GAAG,CAACQ,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC2B,oBAAoB,CAACd,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7DrB,GAAG,CAACQ,EAAE,CAAC,gBAAgB,EAAE,IAAI,CAAC4B,qBAAqB,CAACf,IAAI,CAAC,IAAI,CAAC,CAAC;IAC/DrB,GAAG,CAACQ,EAAE,CAAC,UAAU,EAAE,IAAI,CAAC6B,eAAe,CAAChB,IAAI,CAAC,IAAI,CAAC,CAAC;IACnDrB,GAAG,CAACQ,EAAE,CAAC,cAAc,EAAE,IAAI,CAAC8B,mBAAmB,CAACjB,IAAI,CAAC,IAAI,CAAC,CAAC;EAC7D;;EAEA;EACA;EACAkB,YAAYA,CAACC,EAAE,EAAE;IACf,MAAMxC,GAAG,GAAG,IAAI,CAAC3B,UAAU;IAC3B,IAAI,OAAO,IAAI,CAACb,QAAQ,KAAK,UAAU,EAAE;MACvC,IAAI,CAACG,QAAQ,CACVuD,OAAO,EAAE,CACTuB,IAAI,CAAC,MAAM,IAAI,CAACjF,QAAQ,EAAE,CAAC,CAC3BiF,IAAI,CAAEC,IAAI,IAAK;QACd,IAAIA,IAAI,KAAKC,SAAS,EAAE;UACtB,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;YAC5B1C,GAAG,CAACiB,IAAI,CAAC,OAAO,EAAE,IAAI2B,SAAS,CAAC,2BAA2B,CAAC,CAAC;YAC7D;UACF;UACA,IAAI,CAAC/F,oBAAoB,CAACW,QAAQ,GAAG,IAAI,CAACA,QAAQ,GAAGkF,IAAI;QAC3D,CAAC,MAAM;UACL,IAAI,CAAC7F,oBAAoB,CAACW,QAAQ,GAAG,IAAI,CAACA,QAAQ,GAAG,IAAI;QAC3D;QACAgF,EAAE,EAAE;MACN,CAAC,CAAC,CACDK,KAAK,CAAEzD,GAAG,IAAK;QACdY,GAAG,CAACiB,IAAI,CAAC,OAAO,EAAE7B,GAAG,CAAC;MACxB,CAAC,CAAC;IACN,CAAC,MAAM,IAAI,IAAI,CAAC5B,QAAQ,KAAK,IAAI,EAAE;MACjCgF,EAAE,EAAE;IACN,CAAC,MAAM;MACLpG,MAAM,CAAC,IAAI,CAACS,oBAAoB,EAAG6F,IAAI,IAAK;QAC1C,IAAIC,SAAS,KAAKD,IAAI,EAAE;UACtB,IAAI,CAAC7F,oBAAoB,CAACW,QAAQ,GAAG,IAAI,CAACA,QAAQ,GAAGkF,IAAI;QAC3D;QACAF,EAAE,EAAE;MACN,CAAC,CAAC;IACJ;EACF;EAEApB,4BAA4BA,CAAC0B,GAAG,EAAE;IAChC,IAAI,CAACP,YAAY,CAAC,MAAM;MACtB,IAAI,CAAClE,UAAU,CAACb,QAAQ,CAAC,IAAI,CAACA,QAAQ,CAAC;IACzC,CAAC,CAAC;EACJ;EAEA8D,sBAAsBA,CAACwB,GAAG,EAAE;IAC1B,IAAI,CAACP,YAAY,CAAC,MAAM;MACtB,MAAMQ,cAAc,GAAG7G,KAAK,CAAC8G,uBAAuB,CAAC,IAAI,CAAClG,IAAI,EAAE,IAAI,CAACU,QAAQ,EAAEsF,GAAG,CAACG,IAAI,CAAC;MACxF,IAAI,CAAC5E,UAAU,CAACb,QAAQ,CAACuF,cAAc,CAAC;IAC1C,CAAC,CAAC;EACJ;EAEAxB,eAAeA,CAACuB,GAAG,EAAE;IACnB,IAAI,CAACP,YAAY,CAAC,MAAM;MACtB,IAAI;QACF,IAAI,CAACW,WAAW,GAAG/G,IAAI,CAACgH,YAAY,CAACL,GAAG,CAACM,UAAU,CAAC;QACpD,IAAI,CAAC/E,UAAU,CAACgF,8BAA8B,CAAC,IAAI,CAACH,WAAW,CAACI,SAAS,EAAE,IAAI,CAACJ,WAAW,CAACK,QAAQ,CAAC;MACvG,CAAC,CAAC,OAAOnE,GAAG,EAAE;QACZ,IAAI,CAACf,UAAU,CAAC4C,IAAI,CAAC,OAAO,EAAE7B,GAAG,CAAC;MACpC;IACF,CAAC,CAAC;EACJ;EAEAoC,uBAAuBA,CAACsB,GAAG,EAAE;IAC3B,IAAI;MACF3G,IAAI,CAACqH,eAAe,CAAC,IAAI,CAACN,WAAW,EAAE,IAAI,CAAC1F,QAAQ,EAAEsF,GAAG,CAACW,IAAI,CAAC;MAC/D,IAAI,CAACpF,UAAU,CAACqF,2BAA2B,CAAC,IAAI,CAACR,WAAW,CAACK,QAAQ,CAAC;IACxE,CAAC,CAAC,OAAOnE,GAAG,EAAE;MACZ,IAAI,CAACf,UAAU,CAAC4C,IAAI,CAAC,OAAO,EAAE7B,GAAG,CAAC;IACpC;EACF;EAEAqC,oBAAoBA,CAACqB,GAAG,EAAE;IACxB,IAAI;MACF3G,IAAI,CAACwH,eAAe,CAAC,IAAI,CAACT,WAAW,EAAEJ,GAAG,CAACW,IAAI,CAAC;MAChD,IAAI,CAACP,WAAW,GAAG,IAAI;IACzB,CAAC,CAAC,OAAO9D,GAAG,EAAE;MACZ,IAAI,CAACf,UAAU,CAAC4C,IAAI,CAAC,OAAO,EAAE7B,GAAG,CAAC;IACpC;EACF;EAEAsC,qBAAqBA,CAACoB,GAAG,EAAE;IACzB,IAAI,CAAChE,SAAS,GAAGgE,GAAG,CAAChE,SAAS;IAC9B,IAAI,CAACC,SAAS,GAAG+D,GAAG,CAAC/D,SAAS;EAChC;EAEA6C,oBAAoBA,CAACkB,GAAG,EAAE;IACxB,IAAI,IAAI,CAAC7E,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,GAAG,KAAK;MACxB,IAAI,CAACC,UAAU,GAAG,IAAI;MACtB6C,YAAY,CAAC,IAAI,CAACZ,uBAAuB,CAAC;;MAE1C;MACA,IAAI,IAAI,CAACF,mBAAmB,EAAE;QAC5B,IAAI,CAACA,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC;QACpC;QACA;QACA,IAAI,CAACA,mBAAmB,GAAG,IAAI;MACjC;MACA,IAAI,CAACgB,IAAI,CAAC,SAAS,CAAC;IACtB;IACA,MAAM;MAAEvB;IAAY,CAAC,GAAG,IAAI;IAC5B,IAAI,CAACA,WAAW,GAAG,IAAI;IACvB,IAAI,CAACkE,aAAa,GAAG,IAAI;IACzB,IAAIlE,WAAW,EAAE;MACfA,WAAW,CAACmE,mBAAmB,CAAC,IAAI,CAACxF,UAAU,CAAC;IAClD;IACA,IAAI,CAACyF,gBAAgB,EAAE;EACzB;;EAEA;EACA;EACAC,2BAA2BA,CAAC3E,GAAG,EAAE;IAC/B,IAAI,IAAI,CAACjB,gBAAgB,EAAE;MACzB;MACA;IACF;IACA,IAAI,CAACA,gBAAgB,GAAG,IAAI;IAC5B4C,YAAY,CAAC,IAAI,CAACZ,uBAAuB,CAAC;IAC1C,IAAI,IAAI,CAACF,mBAAmB,EAAE;MAC5B,OAAO,IAAI,CAACA,mBAAmB,CAACb,GAAG,CAAC;IACtC;IACA,IAAI,CAAC6B,IAAI,CAAC,OAAO,EAAE7B,GAAG,CAAC;EACzB;;EAEA;EACA;EACA;EACA4B,iBAAiBA,CAAC5B,GAAG,EAAE;IACrB,IAAI,IAAI,CAACnB,WAAW,EAAE;MACpB,OAAO,IAAI,CAAC8F,2BAA2B,CAAC3E,GAAG,CAAC;IAC9C;IACA,IAAI,CAAChB,UAAU,GAAG,KAAK;IACvB,IAAI,CAACe,gBAAgB,CAACC,GAAG,CAAC;IAC1B,IAAI,CAAC6B,IAAI,CAAC,OAAO,EAAE7B,GAAG,CAAC;EACzB;;EAEA;EACAuC,mBAAmBA,CAACmB,GAAG,EAAE;IACvB,IAAI,IAAI,CAAC7E,WAAW,EAAE;MACpB,OAAO,IAAI,CAAC8F,2BAA2B,CAACjB,GAAG,CAAC;IAC9C;IACA,MAAMpD,WAAW,GAAG,IAAI,CAACA,WAAW;IAEpC,IAAI,CAACA,WAAW,EAAE;MAChB,IAAI,CAACsB,iBAAiB,CAAC8B,GAAG,CAAC;MAC3B;IACF;IAEA,IAAI,CAACpD,WAAW,GAAG,IAAI;IACvBA,WAAW,CAACD,WAAW,CAACqD,GAAG,EAAE,IAAI,CAACzE,UAAU,CAAC;EAC/C;EAEAyD,qBAAqBA,CAACgB,GAAG,EAAE;IACzB;IACA,IAAI,CAACpD,WAAW,CAACsE,oBAAoB,CAAClB,GAAG,CAAC;EAC5C;EAEAf,cAAcA,CAACe,GAAG,EAAE;IAClB;IACA,IAAI,CAACpD,WAAW,CAACuE,aAAa,CAACnB,GAAG,CAAC;EACrC;EAEAd,sBAAsBA,CAACc,GAAG,EAAE;IAC1B;IACA,IAAI,CAACpD,WAAW,CAACwE,qBAAqB,CAAC,IAAI,CAAC7F,UAAU,CAAC;EACzD;EAEA4D,iBAAiBA,CAACa,GAAG,EAAE;IACrB;IACA,IAAI,CAACpD,WAAW,CAACyE,gBAAgB,CAAC,IAAI,CAAC9F,UAAU,CAAC;EACpD;EAEA6D,sBAAsBA,CAACY,GAAG,EAAE;IAC1B;IACA,IAAI,CAACpD,WAAW,CAAC0E,qBAAqB,CAACtB,GAAG,EAAE,IAAI,CAACzE,UAAU,CAAC;EAC9D;EAEA8D,oBAAoBA,CAACW,GAAG,EAAE;IACxB;IACA;IACA;IACA,IAAI,IAAI,CAACpD,WAAW,CAAC2E,IAAI,EAAE;MACzB,IAAI,CAAChG,UAAU,CAACiG,gBAAgB,CAAC,IAAI,CAAC5E,WAAW,CAAC2E,IAAI,CAAC,GAAG,IAAI,CAAC3E,WAAW,CAAC6E,IAAI;IACjF;EACF;EAEAnC,qBAAqBA,CAACU,GAAG,EAAE;IACzB,IAAI,CAACpD,WAAW,CAAC8E,oBAAoB,CAAC,IAAI,CAACnG,UAAU,CAAC;EACxD;EAEAgE,eAAeA,CAACS,GAAG,EAAE;IACnB,IAAI,CAACpD,WAAW,CAAC+E,cAAc,CAAC3B,GAAG,EAAE,IAAI,CAACzE,UAAU,CAAC;EACvD;EAEAiE,mBAAmBA,CAACQ,GAAG,EAAE;IACvB,IAAI,CAAC7B,IAAI,CAAC,cAAc,EAAE6B,GAAG,CAAC;EAChC;EAEAjB,aAAaA,CAACiB,GAAG,EAAE;IACjB,IAAI,CAAC7B,IAAI,CAAC,QAAQ,EAAE6B,GAAG,CAAC;EAC1B;EAEAnC,cAAcA,CAAA,EAAG;IACf,IAAI+D,MAAM,GAAG,IAAI,CAAC7H,oBAAoB;IAEtC,IAAI4G,IAAI,GAAG;MACT3G,IAAI,EAAE4H,MAAM,CAAC5H,IAAI;MACjBC,QAAQ,EAAE2H,MAAM,CAAC3H;IACnB,CAAC;IAED,IAAI4H,OAAO,GAAGD,MAAM,CAACE,gBAAgB,IAAIF,MAAM,CAACG,yBAAyB;IACzE,IAAIF,OAAO,EAAE;MACXlB,IAAI,CAACmB,gBAAgB,GAAGD,OAAO;IACjC;IACA,IAAID,MAAM,CAACjH,WAAW,EAAE;MACtBgG,IAAI,CAAChG,WAAW,GAAG,EAAE,GAAGiH,MAAM,CAACjH,WAAW;IAC5C;IACA,IAAIiH,MAAM,CAACI,iBAAiB,EAAE;MAC5BrB,IAAI,CAACqB,iBAAiB,GAAGC,MAAM,CAACC,QAAQ,CAACN,MAAM,CAACI,iBAAiB,EAAE,EAAE,CAAC,CAAC;IACzE;IACA,IAAIJ,MAAM,CAACO,YAAY,EAAE;MACvBxB,IAAI,CAACwB,YAAY,GAAGF,MAAM,CAACC,QAAQ,CAACN,MAAM,CAACO,YAAY,EAAE,EAAE,CAAC,CAAC;IAC/D;IACA,IAAIP,MAAM,CAACQ,mCAAmC,EAAE;MAC9CzB,IAAI,CAACyB,mCAAmC,GAAGH,MAAM,CAACC,QAAQ,CAACN,MAAM,CAACQ,mCAAmC,EAAE,EAAE,CAAC,CAAC;IAC7G;IACA,IAAIR,MAAM,CAACS,OAAO,EAAE;MAClB1B,IAAI,CAAC0B,OAAO,GAAGT,MAAM,CAACS,OAAO;IAC/B;IAEA,OAAO1B,IAAI;EACb;EAEA2B,MAAMA,CAACC,MAAM,EAAE/F,KAAK,EAAE;IACpB,IAAI+F,MAAM,CAAC3F,WAAW,KAAKJ,KAAK,EAAE;MAChC,IAAIU,GAAG,GAAG,IAAI,CAAC3B,UAAU;MAEzB,IAAI,IAAI,CAACpB,IAAI,IAAI,IAAI,CAACA,IAAI,CAACqD,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QAC7CN,GAAG,CAACO,OAAO,CAAC,IAAI,CAACtD,IAAI,GAAG,YAAY,GAAG,IAAI,CAACD,IAAI,CAAC;MACnD,CAAC,MAAM;QACLgD,GAAG,CAACO,OAAO,CAAC,IAAI,CAACvD,IAAI,EAAE,IAAI,CAACC,IAAI,CAAC;MACnC;;MAEA;MACA+C,GAAG,CAACQ,EAAE,CAAC,SAAS,EAAE,YAAY;QAC5BR,GAAG,CAACoF,MAAM,CAACC,MAAM,CAACvG,SAAS,EAAEuG,MAAM,CAACtG,SAAS,CAAC;MAChD,CAAC,CAAC;IACJ,CAAC,MAAM,IAAIsG,MAAM,CAACzG,UAAU,CAAC0B,OAAO,CAAChB,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MAClD+F,MAAM,CAACzG,UAAU,CAAC0G,MAAM,CAACD,MAAM,CAACzG,UAAU,CAAC0B,OAAO,CAAChB,KAAK,CAAC,EAAE,CAAC,CAAC;IAC/D;EACF;EAEAiG,aAAaA,CAACC,GAAG,EAAEC,MAAM,EAAEC,OAAO,EAAE;IAClC,OAAO,IAAI,CAAC5H,MAAM,CAACyH,aAAa,CAACC,GAAG,EAAEC,MAAM,EAAEC,OAAO,CAAC;EACxD;EAEAC,aAAaA,CAACH,GAAG,EAAEC,MAAM,EAAE;IACzB,OAAO,IAAI,CAAC3H,MAAM,CAAC6H,aAAa,CAACH,GAAG,EAAEC,MAAM,CAAC;EAC/C;;EAEA;EACAG,gBAAgBA,CAACC,GAAG,EAAE;IACpB,OAAO,GAAG,GAAGA,GAAG,CAACC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,GAAG;EAC5C;;EAEA;EACAC,aAAaA,CAACF,GAAG,EAAE;IACjB,IAAIG,YAAY,GAAG,KAAK;IACxB,IAAIC,OAAO,GAAG,GAAG;IAEjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,GAAG,CAACjG,MAAM,EAAEsG,CAAC,EAAE,EAAE;MACnC,IAAIxI,CAAC,GAAGmI,GAAG,CAACK,CAAC,CAAC;MACd,IAAIxI,CAAC,KAAK,GAAG,EAAE;QACbuI,OAAO,IAAIvI,CAAC,GAAGA,CAAC;MAClB,CAAC,MAAM,IAAIA,CAAC,KAAK,IAAI,EAAE;QACrBuI,OAAO,IAAIvI,CAAC,GAAGA,CAAC;QAChBsI,YAAY,GAAG,IAAI;MACrB,CAAC,MAAM;QACLC,OAAO,IAAIvI,CAAC;MACd;IACF;IAEAuI,OAAO,IAAI,GAAG;IAEd,IAAID,YAAY,KAAK,IAAI,EAAE;MACzBC,OAAO,GAAG,IAAI,GAAGA,OAAO;IAC1B;IAEA,OAAOA,OAAO;EAChB;EAEAnC,gBAAgBA,CAAA,EAAG;IACjB,IAAI,IAAI,CAACF,aAAa,KAAK,IAAI,EAAE;MAC/B,IAAI,CAAClE,WAAW,GAAG,IAAI,CAACd,UAAU,CAACuH,KAAK,EAAE;MAC1C,IAAI,IAAI,CAACzG,WAAW,EAAE;QACpB,IAAI,CAACkE,aAAa,GAAG,KAAK;QAC1B,IAAI,CAACwC,WAAW,GAAG,IAAI;QAEvB,MAAMC,UAAU,GAAG,IAAI,CAAC3G,WAAW,CAAC4G,MAAM,CAAC,IAAI,CAACjI,UAAU,CAAC;QAC3D,IAAIgI,UAAU,EAAE;UACd9G,OAAO,CAACC,QAAQ,CAAC,MAAM;YACrB,IAAI,CAACE,WAAW,CAACD,WAAW,CAAC4G,UAAU,EAAE,IAAI,CAAChI,UAAU,CAAC;YACzD,IAAI,CAACuF,aAAa,GAAG,IAAI;YACzB,IAAI,CAACE,gBAAgB,EAAE;UACzB,CAAC,CAAC;QACJ;MACF,CAAC,MAAM,IAAI,IAAI,CAACsC,WAAW,EAAE;QAC3B,IAAI,CAAC1G,WAAW,GAAG,IAAI;QACvB,IAAI,CAACuB,IAAI,CAAC,OAAO,CAAC;MACpB;IACF;EACF;EAEA3B,KAAKA,CAAC1C,MAAM,EAAE2J,MAAM,EAAEzG,QAAQ,EAAE;IAC9B;IACA,IAAIR,KAAK;IACT,IAAIkH,MAAM;IACV,IAAIC,WAAW;IACf,IAAIC,gBAAgB;IACpB,IAAIC,aAAa;IAEjB,IAAI/J,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK+F,SAAS,EAAE;MAC3C,MAAM,IAAIC,SAAS,CAAC,6CAA6C,CAAC;IACpE,CAAC,MAAM,IAAI,OAAOhG,MAAM,CAAC0J,MAAM,KAAK,UAAU,EAAE;MAC9CG,WAAW,GAAG7J,MAAM,CAACgK,aAAa,IAAI,IAAI,CAAC/J,oBAAoB,CAAC+J,aAAa;MAC7EJ,MAAM,GAAGlH,KAAK,GAAG1C,MAAM;MACvB,IAAI,OAAO2J,MAAM,KAAK,UAAU,EAAE;QAChCjH,KAAK,CAACQ,QAAQ,GAAGR,KAAK,CAACQ,QAAQ,IAAIyG,MAAM;MAC3C;IACF,CAAC,MAAM;MACLE,WAAW,GAAG,IAAI,CAAC5J,oBAAoB,CAAC+J,aAAa;MACrDtH,KAAK,GAAG,IAAI/C,KAAK,CAACK,MAAM,EAAE2J,MAAM,EAAEzG,QAAQ,CAAC;MAC3C,IAAI,CAACR,KAAK,CAACQ,QAAQ,EAAE;QACnB0G,MAAM,GAAG,IAAI,IAAI,CAAC7I,QAAQ,CAAC,CAACuD,OAAO,EAAEC,MAAM,KAAK;UAC9C7B,KAAK,CAACQ,QAAQ,GAAG,CAACV,GAAG,EAAEyH,GAAG,KAAMzH,GAAG,GAAG+B,MAAM,CAAC/B,GAAG,CAAC,GAAG8B,OAAO,CAAC2F,GAAG,CAAE;QACnE,CAAC,CAAC;MACJ;IACF;IAEA,IAAIJ,WAAW,EAAE;MACfE,aAAa,GAAGrH,KAAK,CAACQ,QAAQ;MAE9B4G,gBAAgB,GAAGtG,UAAU,CAAC,MAAM;QAClC,IAAIU,KAAK,GAAG,IAAIZ,KAAK,CAAC,oBAAoB,CAAC;QAE3CX,OAAO,CAACC,QAAQ,CAAC,MAAM;UACrBF,KAAK,CAACG,WAAW,CAACqB,KAAK,EAAE,IAAI,CAACzC,UAAU,CAAC;QAC3C,CAAC,CAAC;QAEFsI,aAAa,CAAC7F,KAAK,CAAC;;QAEpB;QACA;QACAxB,KAAK,CAACQ,QAAQ,GAAG,MAAM,CAAC,CAAC;;QAEzB;QACA,IAAIgH,KAAK,GAAG,IAAI,CAAClI,UAAU,CAAC0B,OAAO,CAAChB,KAAK,CAAC;QAC1C,IAAIwH,KAAK,GAAG,CAAC,CAAC,EAAE;UACd,IAAI,CAAClI,UAAU,CAAC0G,MAAM,CAACwB,KAAK,EAAE,CAAC,CAAC;QAClC;QAEA,IAAI,CAAChD,gBAAgB,EAAE;MACzB,CAAC,EAAE2C,WAAW,CAAC;MAEfnH,KAAK,CAACQ,QAAQ,GAAG,CAACV,GAAG,EAAEyH,GAAG,KAAK;QAC7B9F,YAAY,CAAC2F,gBAAgB,CAAC;QAC9BC,aAAa,CAACvH,GAAG,EAAEyH,GAAG,CAAC;MACzB,CAAC;IACH;IAEA,IAAI,IAAI,CAAChI,MAAM,IAAI,CAACS,KAAK,CAACT,MAAM,EAAE;MAChCS,KAAK,CAACT,MAAM,GAAG,IAAI;IACrB;IAEA,IAAIS,KAAK,CAACyH,OAAO,IAAI,CAACzH,KAAK,CAACyH,OAAO,CAACjJ,MAAM,EAAE;MAC1CwB,KAAK,CAACyH,OAAO,CAACjJ,MAAM,GAAG,IAAI,CAACA,MAAM;IACpC;IAEA,IAAI,CAAC,IAAI,CAACM,UAAU,EAAE;MACpBmB,OAAO,CAACC,QAAQ,CAAC,MAAM;QACrBF,KAAK,CAACG,WAAW,CAAC,IAAIS,KAAK,CAAC,gEAAgE,CAAC,EAAE,IAAI,CAAC7B,UAAU,CAAC;MACjH,CAAC,CAAC;MACF,OAAOmI,MAAM;IACf;IAEA,IAAI,IAAI,CAACxI,OAAO,EAAE;MAChBuB,OAAO,CAACC,QAAQ,CAAC,MAAM;QACrBF,KAAK,CAACG,WAAW,CAAC,IAAIS,KAAK,CAAC,wCAAwC,CAAC,EAAE,IAAI,CAAC7B,UAAU,CAAC;MACzF,CAAC,CAAC;MACF,OAAOmI,MAAM;IACf;IAEA,IAAI,CAAC5H,UAAU,CAACoI,IAAI,CAAC1H,KAAK,CAAC;IAC3B,IAAI,CAACwE,gBAAgB,EAAE;IACvB,OAAO0C,MAAM;EACf;EAEAS,GAAGA,CAAA,EAAG;IACJ,IAAI,CAAC5I,UAAU,CAAC4I,GAAG,EAAE;EACvB;EAEAC,KAAKA,CAAA,EAAG;IACN,IAAI,CAAC7I,UAAU,CAAC6I,KAAK,EAAE;EACzB;EAEAC,GAAGA,CAAC3E,EAAE,EAAE;IACN,IAAI,CAACxE,OAAO,GAAG,IAAI;;IAEnB;IACA,IAAI,CAAC,IAAI,CAACK,UAAU,CAACJ,WAAW,EAAE;MAChC,IAAIuE,EAAE,EAAE;QACNA,EAAE,EAAE;MACN,CAAC,MAAM;QACL,OAAO,IAAI,CAAC7E,QAAQ,CAACuD,OAAO,EAAE;MAChC;IACF;IAEA,IAAI,IAAI,CAACxB,WAAW,IAAI,CAAC,IAAI,CAACtB,UAAU,EAAE;MACxC;MACA;MACA,IAAI,CAACC,UAAU,CAACC,MAAM,CAAC+B,OAAO,EAAE;IAClC,CAAC,MAAM;MACL,IAAI,CAAChC,UAAU,CAAC8I,GAAG,EAAE;IACvB;IAEA,IAAI3E,EAAE,EAAE;MACN,IAAI,CAACnE,UAAU,CAACwC,IAAI,CAAC,KAAK,EAAE2B,EAAE,CAAC;IACjC,CAAC,MAAM;MACL,OAAO,IAAI,IAAI,CAAC7E,QAAQ,CAAEuD,OAAO,IAAK;QACpC,IAAI,CAAC7C,UAAU,CAACwC,IAAI,CAAC,KAAK,EAAEK,OAAO,CAAC;MACtC,CAAC,CAAC;IACJ;EACF;AACF;;AAEA;AACAxE,MAAM,CAACH,KAAK,GAAGA,KAAK;AAEpB6K,MAAM,CAACC,OAAO,GAAG3K,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}