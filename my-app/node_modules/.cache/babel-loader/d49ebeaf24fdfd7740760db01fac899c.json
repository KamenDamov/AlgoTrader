{"ast":null,"code":"/*!\r\n * on-finished\r\n * Copyright(c) 2013 Jonathan Ong\r\n * Copyright(c) 2014 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n'use strict';\n/**\r\n * Module exports.\r\n * @public\r\n */\n\nmodule.exports = onFinished;\nmodule.exports.isFinished = isFinished;\n/**\r\n * Module dependencies.\r\n * @private\r\n */\n\nvar asyncHooks = tryRequireAsyncHooks();\n\nvar first = require('ee-first');\n/**\r\n * Variables.\r\n * @private\r\n */\n\n/* istanbul ignore next */\n\n\nvar defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  process.nextTick(fn.bind.apply(fn, arguments));\n};\n/**\r\n * Invoke callback when the response has finished, useful for\r\n * cleaning up resources afterwards.\r\n *\r\n * @param {object} msg\r\n * @param {function} listener\r\n * @return {object}\r\n * @public\r\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg);\n    return msg;\n  } // attach the listener to the message\n\n\n  attachListener(msg, wrap(listener));\n  return msg;\n}\n/**\r\n * Determine if message is already finished.\r\n *\r\n * @param {object} msg\r\n * @return {boolean}\r\n * @public\r\n */\n\n\nfunction isFinished(msg) {\n  var socket = msg.socket;\n\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || socket && !socket.writable);\n  }\n\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);\n  } // don't know\n\n\n  return undefined;\n}\n/**\r\n * Attach a finished listener to the message.\r\n *\r\n * @param {object} msg\r\n * @param {function} callback\r\n * @private\r\n */\n\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg;\n  var eeSocket;\n  var finished = false;\n\n  function onFinish(error) {\n    eeMsg.cancel();\n    eeSocket.cancel();\n    finished = true;\n    callback(error);\n  } // finished on first message event\n\n\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);\n\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket);\n    if (finished) return;\n    if (eeMsg !== eeSocket) return; // finished on first socket event\n\n    eeSocket = first([[socket, 'error', 'close']], onFinish);\n  }\n\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket);\n    return;\n  } // wait for socket to be assigned\n\n\n  msg.on('socket', onSocket);\n\n  if (msg.socket === undefined) {\n    // istanbul ignore next: node.js 0.8 patch\n    patchAssignSocket(msg, onSocket);\n  }\n}\n/**\r\n * Attach the listener to the message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\n\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished; // create a private single listener with queue\n\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg);\n    attachFinishedListener(msg, attached);\n  }\n\n  attached.queue.push(listener);\n}\n/**\r\n * Create listener on message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\n\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null;\n    if (!listener.queue) return;\n    var queue = listener.queue;\n    listener.queue = null;\n\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg);\n    }\n  }\n\n  listener.queue = [];\n  return listener;\n}\n/**\r\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\r\n *\r\n * @param {ServerResponse} res\r\n * @param {function} callback\r\n * @private\r\n */\n// istanbul ignore next: node.js 0.8 patch\n\n\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket;\n  if (typeof assignSocket !== 'function') return; // res.on('socket', callback) is broken in 0.8\n\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket);\n    callback(socket);\n  };\n}\n/**\r\n * Try to require async_hooks\r\n * @private\r\n */\n\n\nfunction tryRequireAsyncHooks() {\n  try {\n    return require('async_hooks');\n  } catch (e) {\n    return {};\n  }\n}\n/**\r\n * Wrap function with async resource, if possible.\r\n * AsyncResource.bind static method backported.\r\n * @private\r\n */\n\n\nfunction wrap(fn) {\n  var res; // create anonymous resource\n\n  if (asyncHooks.AsyncResource) {\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');\n  } // incompatible node.js\n\n\n  if (!res || !res.runInAsyncScope) {\n    return fn;\n  } // return bound function\n\n\n  return res.runInAsyncScope.bind(res, fn, null);\n}","map":{"version":3,"names":["module","exports","onFinished","isFinished","asyncHooks","tryRequireAsyncHooks","first","require","defer","setImmediate","fn","process","nextTick","bind","apply","arguments","msg","listener","attachListener","wrap","socket","finished","Boolean","writable","complete","upgrade","readable","undefined","attachFinishedListener","callback","eeMsg","eeSocket","onFinish","error","cancel","onSocket","removeListener","on","patchAssignSocket","attached","__onFinished","queue","createListener","push","err","i","length","res","assignSocket","_assignSocket","call","e","AsyncResource","name","runInAsyncScope"],"sources":["C:/Users/Kamen/ML/AlgoTrader/my-app/node_modules/on-finished/index.js"],"sourcesContent":["/*!\r\n * on-finished\r\n * Copyright(c) 2013 Jonathan Ong\r\n * Copyright(c) 2014 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nmodule.exports = onFinished\r\nmodule.exports.isFinished = isFinished\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar asyncHooks = tryRequireAsyncHooks()\r\nvar first = require('ee-first')\r\n\r\n/**\r\n * Variables.\r\n * @private\r\n */\r\n\r\n/* istanbul ignore next */\r\nvar defer = typeof setImmediate === 'function'\r\n  ? setImmediate\r\n  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }\r\n\r\n/**\r\n * Invoke callback when the response has finished, useful for\r\n * cleaning up resources afterwards.\r\n *\r\n * @param {object} msg\r\n * @param {function} listener\r\n * @return {object}\r\n * @public\r\n */\r\n\r\nfunction onFinished (msg, listener) {\r\n  if (isFinished(msg) !== false) {\r\n    defer(listener, null, msg)\r\n    return msg\r\n  }\r\n\r\n  // attach the listener to the message\r\n  attachListener(msg, wrap(listener))\r\n\r\n  return msg\r\n}\r\n\r\n/**\r\n * Determine if message is already finished.\r\n *\r\n * @param {object} msg\r\n * @return {boolean}\r\n * @public\r\n */\r\n\r\nfunction isFinished (msg) {\r\n  var socket = msg.socket\r\n\r\n  if (typeof msg.finished === 'boolean') {\r\n    // OutgoingMessage\r\n    return Boolean(msg.finished || (socket && !socket.writable))\r\n  }\r\n\r\n  if (typeof msg.complete === 'boolean') {\r\n    // IncomingMessage\r\n    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))\r\n  }\r\n\r\n  // don't know\r\n  return undefined\r\n}\r\n\r\n/**\r\n * Attach a finished listener to the message.\r\n *\r\n * @param {object} msg\r\n * @param {function} callback\r\n * @private\r\n */\r\n\r\nfunction attachFinishedListener (msg, callback) {\r\n  var eeMsg\r\n  var eeSocket\r\n  var finished = false\r\n\r\n  function onFinish (error) {\r\n    eeMsg.cancel()\r\n    eeSocket.cancel()\r\n\r\n    finished = true\r\n    callback(error)\r\n  }\r\n\r\n  // finished on first message event\r\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)\r\n\r\n  function onSocket (socket) {\r\n    // remove listener\r\n    msg.removeListener('socket', onSocket)\r\n\r\n    if (finished) return\r\n    if (eeMsg !== eeSocket) return\r\n\r\n    // finished on first socket event\r\n    eeSocket = first([[socket, 'error', 'close']], onFinish)\r\n  }\r\n\r\n  if (msg.socket) {\r\n    // socket already assigned\r\n    onSocket(msg.socket)\r\n    return\r\n  }\r\n\r\n  // wait for socket to be assigned\r\n  msg.on('socket', onSocket)\r\n\r\n  if (msg.socket === undefined) {\r\n    // istanbul ignore next: node.js 0.8 patch\r\n    patchAssignSocket(msg, onSocket)\r\n  }\r\n}\r\n\r\n/**\r\n * Attach the listener to the message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\r\n\r\nfunction attachListener (msg, listener) {\r\n  var attached = msg.__onFinished\r\n\r\n  // create a private single listener with queue\r\n  if (!attached || !attached.queue) {\r\n    attached = msg.__onFinished = createListener(msg)\r\n    attachFinishedListener(msg, attached)\r\n  }\r\n\r\n  attached.queue.push(listener)\r\n}\r\n\r\n/**\r\n * Create listener on message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\r\n\r\nfunction createListener (msg) {\r\n  function listener (err) {\r\n    if (msg.__onFinished === listener) msg.__onFinished = null\r\n    if (!listener.queue) return\r\n\r\n    var queue = listener.queue\r\n    listener.queue = null\r\n\r\n    for (var i = 0; i < queue.length; i++) {\r\n      queue[i](err, msg)\r\n    }\r\n  }\r\n\r\n  listener.queue = []\r\n\r\n  return listener\r\n}\r\n\r\n/**\r\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\r\n *\r\n * @param {ServerResponse} res\r\n * @param {function} callback\r\n * @private\r\n */\r\n\r\n// istanbul ignore next: node.js 0.8 patch\r\nfunction patchAssignSocket (res, callback) {\r\n  var assignSocket = res.assignSocket\r\n\r\n  if (typeof assignSocket !== 'function') return\r\n\r\n  // res.on('socket', callback) is broken in 0.8\r\n  res.assignSocket = function _assignSocket (socket) {\r\n    assignSocket.call(this, socket)\r\n    callback(socket)\r\n  }\r\n}\r\n\r\n/**\r\n * Try to require async_hooks\r\n * @private\r\n */\r\n\r\nfunction tryRequireAsyncHooks () {\r\n  try {\r\n    return require('async_hooks')\r\n  } catch (e) {\r\n    return {}\r\n  }\r\n}\r\n\r\n/**\r\n * Wrap function with async resource, if possible.\r\n * AsyncResource.bind static method backported.\r\n * @private\r\n */\r\n\r\nfunction wrap (fn) {\r\n  var res\r\n\r\n  // create anonymous resource\r\n  if (asyncHooks.AsyncResource) {\r\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')\r\n  }\r\n\r\n  // incompatible node.js\r\n  if (!res || !res.runInAsyncScope) {\r\n    return fn\r\n  }\r\n\r\n  // return bound function\r\n  return res.runInAsyncScope.bind(res, fn, null)\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}