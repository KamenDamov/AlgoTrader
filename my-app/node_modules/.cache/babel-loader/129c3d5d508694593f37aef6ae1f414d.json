{"ast":null,"code":"const {\n  dirname\n} = require('path');\n\nconst fileURLToPath = require('../common/file-url-to-path/index.js');\n\nconst fs = require('../fs.js');\n\nconst defaultOptions = {\n  mode: 0o777,\n  recursive: false\n};\n\nconst mkdir = async (path, opts) => {\n  const options = { ...defaultOptions,\n    ...opts\n  }; // if we're not in recursive mode, just call the real mkdir with the path and\n  // the mode option only\n\n  if (!options.recursive) {\n    return fs.mkdir(path, options.mode);\n  }\n\n  const makeDirectory = async (dir, mode) => {\n    // we can't use dirname directly since these functions support URL\n    // objects with the file: protocol as the path input, so first we get a\n    // string path, then we can call dirname on that\n    const parent = dir != null && dir.href && dir.origin ? dirname(fileURLToPath(dir)) : dirname(dir); // if the parent is the dir itself, try to create it. anything but EISDIR\n    // should be rethrown\n\n    if (parent === dir) {\n      try {\n        await fs.mkdir(dir, opts);\n      } catch (err) {\n        if (err.code !== 'EISDIR') {\n          throw err;\n        }\n      }\n\n      return undefined;\n    }\n\n    try {\n      await fs.mkdir(dir, mode);\n      return dir;\n    } catch (err) {\n      // ENOENT means the parent wasn't there, so create that\n      if (err.code === 'ENOENT') {\n        const made = await makeDirectory(parent, mode);\n        await makeDirectory(dir, mode); // return the shallowest path we created, i.e. the result of creating\n        // the parent\n\n        return made;\n      } // an EEXIST means there's already something there\n      // an EROFS means we have a read-only filesystem and can't create a dir\n      // any other error is fatal and we should give up now\n\n\n      if (err.code !== 'EEXIST' && err.code !== 'EROFS') {\n        throw err;\n      } // stat the directory, if the result is a directory, then we successfully\n      // created this one so return its path. otherwise, we reject with the\n      // original error by ignoring the error in the catch\n\n\n      try {\n        const stat = await fs.stat(dir);\n\n        if (stat.isDirectory()) {\n          // if it already existed, we didn't create anything so return\n          // undefined\n          return undefined;\n        }\n      } catch (_) {} // if the thing that's there isn't a directory, then just re-throw\n\n\n      throw err;\n    }\n  };\n\n  return makeDirectory(path, options.mode);\n};\n\nmodule.exports = mkdir;","map":{"version":3,"names":["dirname","require","fileURLToPath","fs","defaultOptions","mode","recursive","mkdir","path","opts","options","makeDirectory","dir","parent","href","origin","err","code","undefined","made","stat","isDirectory","_","module","exports"],"sources":["C:/Users/Kamen/ML/AlgoTrader/node_modules/@npmcli/fs/lib/mkdir/polyfill.js"],"sourcesContent":["const { dirname } = require('path')\n\nconst fileURLToPath = require('../common/file-url-to-path/index.js')\nconst fs = require('../fs.js')\n\nconst defaultOptions = {\n  mode: 0o777,\n  recursive: false,\n}\n\nconst mkdir = async (path, opts) => {\n  const options = { ...defaultOptions, ...opts }\n\n  // if we're not in recursive mode, just call the real mkdir with the path and\n  // the mode option only\n  if (!options.recursive) {\n    return fs.mkdir(path, options.mode)\n  }\n\n  const makeDirectory = async (dir, mode) => {\n    // we can't use dirname directly since these functions support URL\n    // objects with the file: protocol as the path input, so first we get a\n    // string path, then we can call dirname on that\n    const parent = dir != null && dir.href && dir.origin\n      ? dirname(fileURLToPath(dir))\n      : dirname(dir)\n\n    // if the parent is the dir itself, try to create it. anything but EISDIR\n    // should be rethrown\n    if (parent === dir) {\n      try {\n        await fs.mkdir(dir, opts)\n      } catch (err) {\n        if (err.code !== 'EISDIR') {\n          throw err\n        }\n      }\n      return undefined\n    }\n\n    try {\n      await fs.mkdir(dir, mode)\n      return dir\n    } catch (err) {\n      // ENOENT means the parent wasn't there, so create that\n      if (err.code === 'ENOENT') {\n        const made = await makeDirectory(parent, mode)\n        await makeDirectory(dir, mode)\n        // return the shallowest path we created, i.e. the result of creating\n        // the parent\n        return made\n      }\n\n      // an EEXIST means there's already something there\n      // an EROFS means we have a read-only filesystem and can't create a dir\n      // any other error is fatal and we should give up now\n      if (err.code !== 'EEXIST' && err.code !== 'EROFS') {\n        throw err\n      }\n\n      // stat the directory, if the result is a directory, then we successfully\n      // created this one so return its path. otherwise, we reject with the\n      // original error by ignoring the error in the catch\n      try {\n        const stat = await fs.stat(dir)\n        if (stat.isDirectory()) {\n          // if it already existed, we didn't create anything so return\n          // undefined\n          return undefined\n        }\n      } catch (_) {}\n\n      // if the thing that's there isn't a directory, then just re-throw\n      throw err\n    }\n  }\n\n  return makeDirectory(path, options.mode)\n}\n\nmodule.exports = mkdir\n"],"mappings":"AAAA,MAAM;EAAEA;AAAF,IAAcC,OAAO,CAAC,MAAD,CAA3B;;AAEA,MAAMC,aAAa,GAAGD,OAAO,CAAC,qCAAD,CAA7B;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,UAAD,CAAlB;;AAEA,MAAMG,cAAc,GAAG;EACrBC,IAAI,EAAE,KADe;EAErBC,SAAS,EAAE;AAFU,CAAvB;;AAKA,MAAMC,KAAK,GAAG,OAAOC,IAAP,EAAaC,IAAb,KAAsB;EAClC,MAAMC,OAAO,GAAG,EAAE,GAAGN,cAAL;IAAqB,GAAGK;EAAxB,CAAhB,CADkC,CAGlC;EACA;;EACA,IAAI,CAACC,OAAO,CAACJ,SAAb,EAAwB;IACtB,OAAOH,EAAE,CAACI,KAAH,CAASC,IAAT,EAAeE,OAAO,CAACL,IAAvB,CAAP;EACD;;EAED,MAAMM,aAAa,GAAG,OAAOC,GAAP,EAAYP,IAAZ,KAAqB;IACzC;IACA;IACA;IACA,MAAMQ,MAAM,GAAGD,GAAG,IAAI,IAAP,IAAeA,GAAG,CAACE,IAAnB,IAA2BF,GAAG,CAACG,MAA/B,GACXf,OAAO,CAACE,aAAa,CAACU,GAAD,CAAd,CADI,GAEXZ,OAAO,CAACY,GAAD,CAFX,CAJyC,CAQzC;IACA;;IACA,IAAIC,MAAM,KAAKD,GAAf,EAAoB;MAClB,IAAI;QACF,MAAMT,EAAE,CAACI,KAAH,CAASK,GAAT,EAAcH,IAAd,CAAN;MACD,CAFD,CAEE,OAAOO,GAAP,EAAY;QACZ,IAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B;UACzB,MAAMD,GAAN;QACD;MACF;;MACD,OAAOE,SAAP;IACD;;IAED,IAAI;MACF,MAAMf,EAAE,CAACI,KAAH,CAASK,GAAT,EAAcP,IAAd,CAAN;MACA,OAAOO,GAAP;IACD,CAHD,CAGE,OAAOI,GAAP,EAAY;MACZ;MACA,IAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B;QACzB,MAAME,IAAI,GAAG,MAAMR,aAAa,CAACE,MAAD,EAASR,IAAT,CAAhC;QACA,MAAMM,aAAa,CAACC,GAAD,EAAMP,IAAN,CAAnB,CAFyB,CAGzB;QACA;;QACA,OAAOc,IAAP;MACD,CARW,CAUZ;MACA;MACA;;;MACA,IAAIH,GAAG,CAACC,IAAJ,KAAa,QAAb,IAAyBD,GAAG,CAACC,IAAJ,KAAa,OAA1C,EAAmD;QACjD,MAAMD,GAAN;MACD,CAfW,CAiBZ;MACA;MACA;;;MACA,IAAI;QACF,MAAMI,IAAI,GAAG,MAAMjB,EAAE,CAACiB,IAAH,CAAQR,GAAR,CAAnB;;QACA,IAAIQ,IAAI,CAACC,WAAL,EAAJ,EAAwB;UACtB;UACA;UACA,OAAOH,SAAP;QACD;MACF,CAPD,CAOE,OAAOI,CAAP,EAAU,CAAE,CA3BF,CA6BZ;;;MACA,MAAMN,GAAN;IACD;EACF,CAxDD;;EA0DA,OAAOL,aAAa,CAACH,IAAD,EAAOE,OAAO,CAACL,IAAf,CAApB;AACD,CApED;;AAsEAkB,MAAM,CAACC,OAAP,GAAiBjB,KAAjB"},"metadata":{},"sourceType":"script"}