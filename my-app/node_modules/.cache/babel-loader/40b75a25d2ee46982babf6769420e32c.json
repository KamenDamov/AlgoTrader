{"ast":null,"code":"'use strict';\n\nconst finished = require('./end-of-stream');\n\nconst kLastResolve = Symbol('lastResolve');\nconst kLastReject = Symbol('lastReject');\nconst kError = Symbol('error');\nconst kEnded = Symbol('ended');\nconst kLastPromise = Symbol('lastPromise');\nconst kHandlePromise = Symbol('handlePromise');\nconst kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value,\n    done\n  };\n}\n\nfunction readAndResolve(iter) {\n  const resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    const data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return (resolve, reject) => {\n    lastPromise.then(() => {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nconst AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nconst ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({\n  get stream() {\n    return this[kStream];\n  },\n\n  next() {\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    const error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise((resolve, reject) => {\n        process.nextTick(() => {\n          if (this[kError]) {\n            reject(this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    const lastPromise = this[kLastPromise];\n    let promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      const data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  },\n\n  [Symbol.asyncIterator]() {\n    return this;\n  },\n\n  return() {\n    // destroy(err, cb) is a private API\n    // we can guarantee we have that here, because we control the\n    // Readable class this is attached to\n    return new Promise((resolve, reject) => {\n      this[kStream].destroy(null, err => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(createIterResult(undefined, true));\n      });\n    });\n  }\n\n}, AsyncIteratorPrototype);\n\nconst createReadableStreamAsyncIterator = stream => {\n  const iterator = Object.create(ReadableStreamAsyncIteratorPrototype, {\n    [kStream]: {\n      value: stream,\n      writable: true\n    },\n    [kLastResolve]: {\n      value: null,\n      writable: true\n    },\n    [kLastReject]: {\n      value: null,\n      writable: true\n    },\n    [kError]: {\n      value: null,\n      writable: true\n    },\n    [kEnded]: {\n      value: stream._readableState.endEmitted,\n      writable: true\n    },\n    // the function passed to new Promise\n    // is cached so we avoid allocating a new\n    // closure at every run\n    [kHandlePromise]: {\n      value: (resolve, reject) => {\n        const data = iterator[kStream].read();\n\n        if (data) {\n          iterator[kLastPromise] = null;\n          iterator[kLastResolve] = null;\n          iterator[kLastReject] = null;\n          resolve(createIterResult(data, false));\n        } else {\n          iterator[kLastResolve] = resolve;\n          iterator[kLastReject] = reject;\n        }\n      },\n      writable: true\n    }\n  });\n  iterator[kLastPromise] = null;\n  finished(stream, err => {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      const reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    const resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","map":{"version":3,"names":["finished","require","kLastResolve","Symbol","kLastReject","kError","kEnded","kLastPromise","kHandlePromise","kStream","createIterResult","value","done","readAndResolve","iter","resolve","data","read","onReadable","process","nextTick","wrapForNext","lastPromise","reject","then","undefined","AsyncIteratorPrototype","Object","getPrototypeOf","ReadableStreamAsyncIteratorPrototype","setPrototypeOf","stream","next","error","Promise","destroyed","promise","asyncIterator","return","destroy","err","createReadableStreamAsyncIterator","iterator","create","writable","_readableState","endEmitted","code","on","bind","module","exports"],"sources":["C:/Users/Kamen/ML/AlgoTrader/node_modules/readable-stream/lib/internal/streams/async_iterator.js"],"sourcesContent":["'use strict';\n\nconst finished = require('./end-of-stream');\nconst kLastResolve = Symbol('lastResolve');\nconst kLastReject = Symbol('lastReject');\nconst kError = Symbol('error');\nconst kEnded = Symbol('ended');\nconst kLastPromise = Symbol('lastPromise');\nconst kHandlePromise = Symbol('handlePromise');\nconst kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value,\n    done\n  };\n}\nfunction readAndResolve(iter) {\n  const resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    const data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return (resolve, reject) => {\n    lastPromise.then(() => {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nconst AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nconst ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({\n  get stream() {\n    return this[kStream];\n  },\n  next() {\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    const error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise((resolve, reject) => {\n        process.nextTick(() => {\n          if (this[kError]) {\n            reject(this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    const lastPromise = this[kLastPromise];\n    let promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      const data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  },\n  [Symbol.asyncIterator]() {\n    return this;\n  },\n  return() {\n    // destroy(err, cb) is a private API\n    // we can guarantee we have that here, because we control the\n    // Readable class this is attached to\n    return new Promise((resolve, reject) => {\n      this[kStream].destroy(null, err => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(createIterResult(undefined, true));\n      });\n    });\n  }\n}, AsyncIteratorPrototype);\nconst createReadableStreamAsyncIterator = stream => {\n  const iterator = Object.create(ReadableStreamAsyncIteratorPrototype, {\n    [kStream]: {\n      value: stream,\n      writable: true\n    },\n    [kLastResolve]: {\n      value: null,\n      writable: true\n    },\n    [kLastReject]: {\n      value: null,\n      writable: true\n    },\n    [kError]: {\n      value: null,\n      writable: true\n    },\n    [kEnded]: {\n      value: stream._readableState.endEmitted,\n      writable: true\n    },\n    // the function passed to new Promise\n    // is cached so we avoid allocating a new\n    // closure at every run\n    [kHandlePromise]: {\n      value: (resolve, reject) => {\n        const data = iterator[kStream].read();\n        if (data) {\n          iterator[kLastPromise] = null;\n          iterator[kLastResolve] = null;\n          iterator[kLastReject] = null;\n          resolve(createIterResult(data, false));\n        } else {\n          iterator[kLastResolve] = resolve;\n          iterator[kLastReject] = reject;\n        }\n      },\n      writable: true\n    }\n  });\n  iterator[kLastPromise] = null;\n  finished(stream, err => {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      const reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    const resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;"],"mappings":"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"},"metadata":{},"sourceType":"script"}