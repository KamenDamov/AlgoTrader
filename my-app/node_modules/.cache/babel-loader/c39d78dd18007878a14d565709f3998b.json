{"ast":null,"code":"/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes');\n\nvar contentType = require('content-type');\n\nvar createError = require('http-errors');\n\nvar debug = require('debug')('body-parser:json');\n\nvar read = require('../read');\n\nvar typeis = require('type-is');\n/**\n * Module exports.\n */\n\n\nmodule.exports = json;\n/**\n * RegExp to match the first non-space in a string.\n *\n * Allowed whitespace is defined in RFC 7159:\n *\n *    ws = *(\n *            %x20 /              ; Space\n *            %x09 /              ; Horizontal tab\n *            %x0A /              ; Line feed or New line\n *            %x0D )              ; Carriage return\n */\n\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*([^\\x20\\x09\\x0a\\x0d])/; // eslint-disable-line no-control-regex\n\nvar JSON_SYNTAX_CHAR = '#';\nvar JSON_SYNTAX_REGEXP = /#+/g;\n/**\n * Create a middleware to parse JSON bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction json(options) {\n  var opts = options || {};\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var inflate = opts.inflate !== false;\n  var reviver = opts.reviver;\n  var strict = opts.strict !== false;\n  var type = opts.type || 'application/json';\n  var verify = opts.verify || false;\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  } // create the appropriate type checking function\n\n\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n\n  function parse(body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {};\n    }\n\n    if (strict) {\n      var first = firstchar(body);\n\n      if (first !== '{' && first !== '[') {\n        debug('strict violation');\n        throw createStrictSyntaxError(body, first);\n      }\n    }\n\n    try {\n      debug('parse json');\n      return JSON.parse(body, reviver);\n    } catch (e) {\n      throw normalizeJsonSyntaxError(e, {\n        message: e.message,\n        stack: e.stack\n      });\n    }\n  }\n\n  return function jsonParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n\n    req.body = req.body || {}; // skip requests without bodies\n\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n\n    debug('content-type %j', req.headers['content-type']); // determine if request should be parsed\n\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    } // assert charset per RFC 7159 sec 8.1\n\n\n    var charset = getCharset(req) || 'utf-8';\n\n    if (charset.slice(0, 4) !== 'utf-') {\n      debug('invalid charset');\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    } // read\n\n\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n/**\n * Create strict violation syntax error matching native error.\n *\n * @param {string} str\n * @param {string} char\n * @return {Error}\n * @private\n */\n\n\nfunction createStrictSyntaxError(str, char) {\n  var index = str.indexOf(char);\n  var partial = '';\n\n  if (index !== -1) {\n    partial = str.substring(0, index) + JSON_SYNTAX_CHAR;\n\n    for (var i = index + 1; i < str.length; i++) {\n      partial += JSON_SYNTAX_CHAR;\n    }\n  }\n\n  try {\n    JSON.parse(partial);\n    /* istanbul ignore next */\n\n    throw new SyntaxError('strict violation');\n  } catch (e) {\n    return normalizeJsonSyntaxError(e, {\n      message: e.message.replace(JSON_SYNTAX_REGEXP, function (placeholder) {\n        return str.substring(index, index + placeholder.length);\n      }),\n      stack: e.stack\n    });\n  }\n}\n/**\n * Get the first non-whitespace character in a string.\n *\n * @param {string} str\n * @return {function}\n * @private\n */\n\n\nfunction firstchar(str) {\n  var match = FIRST_CHAR_REGEXP.exec(str);\n  return match ? match[1] : undefined;\n}\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\n\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\n/**\n * Normalize a SyntaxError for JSON.parse.\n *\n * @param {SyntaxError} error\n * @param {object} obj\n * @return {SyntaxError}\n */\n\n\nfunction normalizeJsonSyntaxError(error, obj) {\n  var keys = Object.getOwnPropertyNames(error);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key];\n    }\n  } // replace stack before message for Node.js 0.10 and below\n\n\n  error.stack = obj.stack.replace(error.message, obj.message);\n  error.message = obj.message;\n  return error;\n}\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":{"version":3,"names":["bytes","require","contentType","createError","debug","read","typeis","module","exports","json","FIRST_CHAR_REGEXP","JSON_SYNTAX_CHAR","JSON_SYNTAX_REGEXP","options","opts","limit","parse","inflate","reviver","strict","type","verify","TypeError","shouldParse","typeChecker","body","length","first","firstchar","createStrictSyntaxError","JSON","e","normalizeJsonSyntaxError","message","stack","jsonParser","req","res","next","_body","hasBody","headers","charset","getCharset","slice","toUpperCase","encoding","str","char","index","indexOf","partial","substring","i","SyntaxError","replace","placeholder","match","exec","undefined","parameters","toLowerCase","error","obj","keys","Object","getOwnPropertyNames","key","checkType","Boolean"],"sources":["C:/Users/Kamen/ML/AlgoTrader/my-app/node_modules/node_modules/body-parser/lib/types/json.js"],"sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:json')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = json\n\n/**\n * RegExp to match the first non-space in a string.\n *\n * Allowed whitespace is defined in RFC 7159:\n *\n *    ws = *(\n *            %x20 /              ; Space\n *            %x09 /              ; Horizontal tab\n *            %x0A /              ; Line feed or New line\n *            %x0D )              ; Carriage return\n */\n\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*([^\\x20\\x09\\x0a\\x0d])/ // eslint-disable-line no-control-regex\n\nvar JSON_SYNTAX_CHAR = '#'\nvar JSON_SYNTAX_REGEXP = /#+/g\n\n/**\n * Create a middleware to parse JSON bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction json (options) {\n  var opts = options || {}\n\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var inflate = opts.inflate !== false\n  var reviver = opts.reviver\n  var strict = opts.strict !== false\n  var type = opts.type || 'application/json'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {}\n    }\n\n    if (strict) {\n      var first = firstchar(body)\n\n      if (first !== '{' && first !== '[') {\n        debug('strict violation')\n        throw createStrictSyntaxError(body, first)\n      }\n    }\n\n    try {\n      debug('parse json')\n      return JSON.parse(body, reviver)\n    } catch (e) {\n      throw normalizeJsonSyntaxError(e, {\n        message: e.message,\n        stack: e.stack\n      })\n    }\n  }\n\n  return function jsonParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // assert charset per RFC 7159 sec 8.1\n    var charset = getCharset(req) || 'utf-8'\n    if (charset.slice(0, 4) !== 'utf-') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Create strict violation syntax error matching native error.\n *\n * @param {string} str\n * @param {string} char\n * @return {Error}\n * @private\n */\n\nfunction createStrictSyntaxError (str, char) {\n  var index = str.indexOf(char)\n  var partial = ''\n\n  if (index !== -1) {\n    partial = str.substring(0, index) + JSON_SYNTAX_CHAR\n\n    for (var i = index + 1; i < str.length; i++) {\n      partial += JSON_SYNTAX_CHAR\n    }\n  }\n\n  try {\n    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')\n  } catch (e) {\n    return normalizeJsonSyntaxError(e, {\n      message: e.message.replace(JSON_SYNTAX_REGEXP, function (placeholder) {\n        return str.substring(index, index + placeholder.length)\n      }),\n      stack: e.stack\n    })\n  }\n}\n\n/**\n * Get the first non-whitespace character in a string.\n *\n * @param {string} str\n * @return {function}\n * @private\n */\n\nfunction firstchar (str) {\n  var match = FIRST_CHAR_REGEXP.exec(str)\n\n  return match\n    ? match[1]\n    : undefined\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Normalize a SyntaxError for JSON.parse.\n *\n * @param {SyntaxError} error\n * @param {object} obj\n * @return {SyntaxError}\n */\n\nfunction normalizeJsonSyntaxError (error, obj) {\n  var keys = Object.getOwnPropertyNames(error)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key]\n    }\n  }\n\n  // replace stack before message for Node.js 0.10 and below\n  error.stack = obj.stack.replace(error.message, obj.message)\n  error.message = obj.message\n\n  return error\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}