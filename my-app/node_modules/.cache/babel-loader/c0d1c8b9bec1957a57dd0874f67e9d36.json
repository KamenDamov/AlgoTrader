{"ast":null,"code":"const Minipass = require('minipass');\n\nconst _flush = Symbol('_flush');\n\nconst _flushed = Symbol('_flushed');\n\nconst _flushing = Symbol('_flushing');\n\nclass Flush extends Minipass {\n  constructor() {\n    let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof opt === 'function') opt = {\n      flush: opt\n    };\n    super(opt); // or extend this class and provide a 'flush' method in your subclass\n\n    if (typeof opt.flush !== 'function' && typeof this.flush !== 'function') throw new TypeError('must provide flush function in options');\n    this[_flush] = opt.flush || this.flush;\n  }\n\n  emit(ev) {\n    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      data[_key - 1] = arguments[_key];\n    }\n\n    if (ev !== 'end' && ev !== 'finish' || this[_flushed]) return super.emit(ev, ...data);\n    if (this[_flushing]) return;\n    this[_flushing] = true;\n\n    const afterFlush = er => {\n      this[_flushed] = true;\n      er ? super.emit('error', er) : super.emit('end');\n    };\n\n    const ret = this[_flush](afterFlush);\n\n    if (ret && ret.then) ret.then(() => afterFlush(), er => afterFlush(er));\n  }\n\n}\n\nmodule.exports = Flush;","map":{"version":3,"names":["Minipass","require","_flush","Symbol","_flushed","_flushing","Flush","constructor","opt","flush","TypeError","emit","ev","data","afterFlush","er","ret","then","module","exports"],"sources":["C:/Users/Kamen/ML/AlgoTrader/node_modules/minipass-flush/index.js"],"sourcesContent":["const Minipass = require('minipass')\nconst _flush = Symbol('_flush')\nconst _flushed = Symbol('_flushed')\nconst _flushing = Symbol('_flushing')\nclass Flush extends Minipass {\n  constructor (opt = {}) {\n    if (typeof opt === 'function')\n      opt = { flush: opt }\n\n    super(opt)\n\n    // or extend this class and provide a 'flush' method in your subclass\n    if (typeof opt.flush !== 'function' && typeof this.flush !== 'function')\n      throw new TypeError('must provide flush function in options')\n\n    this[_flush] = opt.flush || this.flush\n  }\n\n  emit (ev, ...data) {\n    if ((ev !== 'end' && ev !== 'finish') || this[_flushed])\n      return super.emit(ev, ...data)\n\n    if (this[_flushing])\n      return\n\n    this[_flushing] = true\n\n    const afterFlush = er => {\n      this[_flushed] = true\n      er ? super.emit('error', er) : super.emit('end')\n    }\n\n    const ret = this[_flush](afterFlush)\n    if (ret && ret.then)\n      ret.then(() => afterFlush(), er => afterFlush(er))\n  }\n}\n\nmodule.exports = Flush\n"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMC,MAAM,GAAGC,MAAM,CAAC,QAAD,CAArB;;AACA,MAAMC,QAAQ,GAAGD,MAAM,CAAC,UAAD,CAAvB;;AACA,MAAME,SAAS,GAAGF,MAAM,CAAC,WAAD,CAAxB;;AACA,MAAMG,KAAN,SAAoBN,QAApB,CAA6B;EAC3BO,WAAW,GAAY;IAAA,IAAVC,GAAU,uEAAJ,EAAI;IACrB,IAAI,OAAOA,GAAP,KAAe,UAAnB,EACEA,GAAG,GAAG;MAAEC,KAAK,EAAED;IAAT,CAAN;IAEF,MAAMA,GAAN,EAJqB,CAMrB;;IACA,IAAI,OAAOA,GAAG,CAACC,KAAX,KAAqB,UAArB,IAAmC,OAAO,KAAKA,KAAZ,KAAsB,UAA7D,EACE,MAAM,IAAIC,SAAJ,CAAc,wCAAd,CAAN;IAEF,KAAKR,MAAL,IAAeM,GAAG,CAACC,KAAJ,IAAa,KAAKA,KAAjC;EACD;;EAEDE,IAAI,CAAEC,EAAF,EAAe;IAAA,kCAANC,IAAM;MAANA,IAAM;IAAA;;IACjB,IAAKD,EAAE,KAAK,KAAP,IAAgBA,EAAE,KAAK,QAAxB,IAAqC,KAAKR,QAAL,CAAzC,EACE,OAAO,MAAMO,IAAN,CAAWC,EAAX,EAAe,GAAGC,IAAlB,CAAP;IAEF,IAAI,KAAKR,SAAL,CAAJ,EACE;IAEF,KAAKA,SAAL,IAAkB,IAAlB;;IAEA,MAAMS,UAAU,GAAGC,EAAE,IAAI;MACvB,KAAKX,QAAL,IAAiB,IAAjB;MACAW,EAAE,GAAG,MAAMJ,IAAN,CAAW,OAAX,EAAoBI,EAApB,CAAH,GAA6B,MAAMJ,IAAN,CAAW,KAAX,CAA/B;IACD,CAHD;;IAKA,MAAMK,GAAG,GAAG,KAAKd,MAAL,EAAaY,UAAb,CAAZ;;IACA,IAAIE,GAAG,IAAIA,GAAG,CAACC,IAAf,EACED,GAAG,CAACC,IAAJ,CAAS,MAAMH,UAAU,EAAzB,EAA6BC,EAAE,IAAID,UAAU,CAACC,EAAD,CAA7C;EACH;;AA/B0B;;AAkC7BG,MAAM,CAACC,OAAP,GAAiBb,KAAjB"},"metadata":{},"sourceType":"script"}