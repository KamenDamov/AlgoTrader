{"ast":null,"code":"'use strict';\n\nconst {\n  FetchError,\n  Request,\n  isRedirect\n} = require('minipass-fetch');\n\nconst url = require('url');\n\nconst CachePolicy = require('./cache/policy.js');\n\nconst cache = require('./cache/index.js');\n\nconst remote = require('./remote.js'); // given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\n\n\nconst canFollowRedirect = (request, response, options) => {\n  if (!isRedirect(response.status)) return false;\n  if (options.redirect === 'manual') return false;\n  if (options.redirect === 'error') throw new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect', {\n    code: 'ENOREDIRECT'\n  });\n  if (!response.headers.has('location')) throw new FetchError(`redirect location header missing for: ${request.url}`, 'no-location', {\n    code: 'EINVALIDREDIRECT'\n  });\n  if (request.counter >= request.follow) throw new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect', {\n    code: 'EMAXREDIRECT'\n  });\n  return true;\n}; // given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\n\n\nconst getRedirect = (request, response, options) => {\n  const _opts = { ...options\n  };\n  const location = response.headers.get('location');\n  const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url); // Comment below is used under the following license:\n  // Copyright (c) 2010-2012 Mikeal Rogers\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  // http://www.apache.org/licenses/LICENSE-2.0\n  // Unless required by applicable law or agreed to in writing,\n  // software distributed under the License is distributed on an \"AS\n  // IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n  // express or implied. See the License for the specific language\n  // governing permissions and limitations under the License.\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname) request.headers.delete('authorization'); // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n\n  if (response.status === 303 || request.method === 'POST' && [301, 302].includes(response.status)) {\n    _opts.method = 'GET';\n    _opts.body = null;\n    request.headers.delete('content-length');\n  }\n\n  _opts.headers = {};\n  request.headers.forEach((value, key) => {\n    _opts.headers[key] = value;\n  });\n  _opts.counter = ++request.counter;\n  const redirectReq = new Request(url.format(redirectUrl), _opts);\n  return {\n    request: redirectReq,\n    options: _opts\n  };\n};\n\nconst fetch = async (request, options) => {\n  const response = CachePolicy.storable(request, options) ? await cache(request, options) : await remote(request, options); // if the request wasn't a GET or HEAD, and the response\n  // status is between 200 and 399 inclusive, invalidate the\n  // request url\n\n  if (!['GET', 'HEAD'].includes(request.method) && response.status >= 200 && response.status <= 399) await cache.invalidate(request, options);\n  if (!canFollowRedirect(request, response, options)) return response;\n  const redirect = getRedirect(request, response, options);\n  return fetch(redirect.request, redirect.options);\n};\n\nmodule.exports = fetch;","map":{"version":3,"names":["FetchError","Request","isRedirect","require","url","CachePolicy","cache","remote","canFollowRedirect","request","response","options","status","redirect","code","headers","has","counter","follow","getRedirect","_opts","location","get","redirectUrl","URL","test","undefined","hostname","delete","method","includes","body","forEach","value","key","redirectReq","format","fetch","storable","invalidate","module","exports"],"sources":["C:/Users/Kamen/ML/AlgoTrader/node_modules/make-fetch-happen/lib/fetch.js"],"sourcesContent":["'use strict'\n\nconst { FetchError, Request, isRedirect } = require('minipass-fetch')\nconst url = require('url')\n\nconst CachePolicy = require('./cache/policy.js')\nconst cache = require('./cache/index.js')\nconst remote = require('./remote.js')\n\n// given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\nconst canFollowRedirect = (request, response, options) => {\n  if (!isRedirect(response.status))\n    return false\n\n  if (options.redirect === 'manual')\n    return false\n\n  if (options.redirect === 'error')\n    throw new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect', { code: 'ENOREDIRECT' })\n\n  if (!response.headers.has('location'))\n    throw new FetchError(`redirect location header missing for: ${request.url}`, 'no-location', { code: 'EINVALIDREDIRECT' })\n\n  if (request.counter >= request.follow)\n    throw new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect', { code: 'EMAXREDIRECT' })\n\n  return true\n}\n\n// given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\nconst getRedirect = (request, response, options) => {\n  const _opts = { ...options }\n  const location = response.headers.get('location')\n  const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url)\n  // Comment below is used under the following license:\n  // Copyright (c) 2010-2012 Mikeal Rogers\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  // http://www.apache.org/licenses/LICENSE-2.0\n  // Unless required by applicable law or agreed to in writing,\n  // software distributed under the License is distributed on an \"AS\n  // IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n  // express or implied. See the License for the specific language\n  // governing permissions and limitations under the License.\n\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname)\n    request.headers.delete('authorization')\n\n  // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n  if (response.status === 303 || (request.method === 'POST' && [301, 302].includes(response.status))) {\n    _opts.method = 'GET'\n    _opts.body = null\n    request.headers.delete('content-length')\n  }\n\n  _opts.headers = {}\n  request.headers.forEach((value, key) => {\n    _opts.headers[key] = value\n  })\n\n  _opts.counter = ++request.counter\n  const redirectReq = new Request(url.format(redirectUrl), _opts)\n  return {\n    request: redirectReq,\n    options: _opts,\n  }\n}\n\nconst fetch = async (request, options) => {\n  const response = CachePolicy.storable(request, options)\n    ? await cache(request, options)\n    : await remote(request, options)\n\n  // if the request wasn't a GET or HEAD, and the response\n  // status is between 200 and 399 inclusive, invalidate the\n  // request url\n  if (!['GET', 'HEAD'].includes(request.method) &&\n      response.status >= 200 &&\n      response.status <= 399)\n    await cache.invalidate(request, options)\n\n  if (!canFollowRedirect(request, response, options))\n    return response\n\n  const redirect = getRedirect(request, response, options)\n  return fetch(redirect.request, redirect.options)\n}\n\nmodule.exports = fetch\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}