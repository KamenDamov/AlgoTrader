{"ast":null,"code":"// Copyright 2011 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n// TODO: change the default UDP packet size that node-dns sends\n//       from 4096 to conform to these:\n//       - [requestor's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.3)\n//       - [responders's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.4)\n'use strict';\n\nvar consts = require('./consts'),\n    BufferCursor = require('buffercursor'),\n    BufferCursorOverflow = BufferCursor.BufferCursorOverflow,\n    ipaddr = require('ipaddr.js'),\n    assert = require('assert'),\n    util = require('util');\n\nfunction assertUndefined(val, msg) {\n  assert(typeof val != 'undefined', msg);\n}\n\nvar Packet = module.exports = function () {\n  this.header = {\n    id: 0,\n    qr: 0,\n    opcode: 0,\n    aa: 0,\n    tc: 0,\n    rd: 1,\n    ra: 0,\n    res1: 0,\n    res2: 0,\n    res3: 0,\n    rcode: 0\n  };\n  this.question = [];\n  this.answer = [];\n  this.authority = [];\n  this.additional = [];\n  this.edns_options = []; // TODO: DEPRECATED! Use `.edns.options` instead!\n\n  this.payload = undefined; // TODO: DEPRECATED! Use `.edns.payload` instead!\n};\n\nvar LABEL_POINTER = 0xC0;\n\nvar isPointer = function (len) {\n  return (len & LABEL_POINTER) === LABEL_POINTER;\n};\n\nfunction nameUnpack(buff) {\n  var len,\n      comp,\n      end,\n      pos,\n      part,\n      combine = '';\n  len = buff.readUInt8();\n  comp = false;\n  end = buff.tell();\n\n  while (len !== 0) {\n    if (isPointer(len)) {\n      len -= LABEL_POINTER;\n      len = len << 8;\n      pos = len + buff.readUInt8();\n      if (!comp) end = buff.tell();\n      buff.seek(pos);\n      len = buff.readUInt8();\n      comp = true;\n      continue;\n    }\n\n    part = buff.toString('ascii', len);\n    if (combine.length) combine = combine + '.' + part;else combine = part;\n    len = buff.readUInt8();\n    if (!comp) end = buff.tell();\n  }\n\n  buff.seek(end);\n  return combine;\n}\n\nfunction namePack(str, buff, index) {\n  var offset, dot, part;\n\n  while (str) {\n    if (index[str]) {\n      offset = (LABEL_POINTER << 8) + index[str];\n      buff.writeUInt16BE(offset);\n      break;\n    } else {\n      index[str] = buff.tell();\n      dot = str.indexOf('.');\n\n      if (dot > -1) {\n        part = str.slice(0, dot);\n        str = str.slice(dot + 1);\n      } else {\n        part = str;\n        str = undefined;\n      }\n\n      buff.writeUInt8(part.length);\n      buff.write(part, part.length, 'ascii');\n    }\n  }\n\n  if (!str) {\n    buff.writeUInt8(0);\n  }\n}\n\nvar WRITE_HEADER = 100001,\n    WRITE_TRUNCATE = 100002,\n    WRITE_QUESTION = 100003,\n    WRITE_RESOURCE_RECORD = 100004,\n    WRITE_RESOURCE_WRITE = 100005,\n    WRITE_RESOURCE_DONE = 100006,\n    WRITE_RESOURCE_END = 100007,\n    WRITE_EDNS = 100008,\n    WRITE_END = 100009,\n    WRITE_A = consts.NAME_TO_QTYPE.A,\n    WRITE_AAAA = consts.NAME_TO_QTYPE.AAAA,\n    WRITE_NS = consts.NAME_TO_QTYPE.NS,\n    WRITE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n    WRITE_PTR = consts.NAME_TO_QTYPE.PTR,\n    WRITE_SPF = consts.NAME_TO_QTYPE.SPF,\n    WRITE_MX = consts.NAME_TO_QTYPE.MX,\n    WRITE_SRV = consts.NAME_TO_QTYPE.SRV,\n    WRITE_TXT = consts.NAME_TO_QTYPE.TXT,\n    WRITE_SOA = consts.NAME_TO_QTYPE.SOA,\n    WRITE_OPT = consts.NAME_TO_QTYPE.OPT,\n    WRITE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n    WRITE_TLSA = consts.NAME_TO_QTYPE.TLSA;\n\nfunction writeHeader(buff, packet) {\n  assert(packet.header, 'Packet requires \"header\"');\n  buff.writeUInt16BE(packet.header.id & 0xFFFF);\n  var val = 0;\n  val += packet.header.qr << 15 & 0x8000;\n  val += packet.header.opcode << 11 & 0x7800;\n  val += packet.header.aa << 10 & 0x400;\n  val += packet.header.tc << 9 & 0x200;\n  val += packet.header.rd << 8 & 0x100;\n  val += packet.header.ra << 7 & 0x80;\n  val += packet.header.res1 << 6 & 0x40;\n  val += packet.header.res2 << 5 & 0x20;\n  val += packet.header.res3 << 4 & 0x10;\n  val += packet.header.rcode & 0xF;\n  buff.writeUInt16BE(val & 0xFFFF);\n  assert(packet.question.length == 1, 'DNS requires one question'); // aren't used\n\n  buff.writeUInt16BE(1); // answer offset 6\n\n  buff.writeUInt16BE(packet.answer.length & 0xFFFF); // authority offset 8\n\n  buff.writeUInt16BE(packet.authority.length & 0xFFFF); // additional offset 10\n\n  buff.writeUInt16BE(packet.additional.length & 0xFFFF);\n  return WRITE_QUESTION;\n}\n\nfunction writeTruncate(buff, packet, section, val) {\n  // XXX FIXME TODO truncation is currently done wrong.\n  // Quote rfc2181 section 9\n  // The TC bit should not be set merely because some extra information\n  // could have been included, but there was insufficient room.  This\n  // includes the results of additional section processing.  In such cases\n  // the entire RRSet that will not fit in the response should be omitted,\n  // and the reply sent as is, with the TC bit clear.  If the recipient of\n  // the reply needs the omitted data, it can construct a query for that\n  // data and send that separately.\n  //\n  // TODO IOW only set TC if we hit it in ANSWERS otherwise make sure an\n  // entire RRSet is removed during a truncation.\n  var pos;\n  buff.seek(2);\n  val = buff.readUInt16BE();\n  val |= 1 << 9 & 0x200;\n  buff.seek(2);\n  buff.writeUInt16BE(val);\n\n  switch (section) {\n    case 'answer':\n      pos = 6; // seek to authority and clear it and additional out\n\n      buff.seek(8);\n      buff.writeUInt16BE(0);\n      buff.writeUInt16BE(0);\n      break;\n\n    case 'authority':\n      pos = 8; // seek to additional and clear it out\n\n      buff.seek(10);\n      buff.writeUInt16BE(0);\n      break;\n\n    case 'additional':\n      pos = 10;\n      break;\n  }\n\n  buff.seek(pos);\n  buff.writeUInt16BE(count - 1); // TODO: count not defined!\n\n  buff.seek(last_resource); // TODO: last_resource not defined!\n\n  return WRITE_END;\n}\n\nfunction writeQuestion(buff, val, label_index) {\n  assert(val, 'Packet requires a question');\n  assertUndefined(val.name, 'Question requires a \"name\"');\n  assertUndefined(val.type, 'Question requires a \"type\"');\n  assertUndefined(val.class, 'Questionn requires a \"class\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  return WRITE_RESOURCE_RECORD;\n}\n\nfunction writeResource(buff, val, label_index, rdata) {\n  assert(val, 'Resource must be defined');\n  assertUndefined(val.name, 'Resource record requires \"name\"');\n  assertUndefined(val.type, 'Resource record requires \"type\"');\n  assertUndefined(val.class, 'Resource record requires \"class\"');\n  assertUndefined(val.ttl, 'Resource record requires \"ttl\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  buff.writeUInt32BE(val.ttl & 0xFFFFFFFF);\n  rdata.pos = buff.tell();\n  buff.writeUInt16BE(0); // if there is rdata, then this value will be updated\n  // to the correct value by 'writeResourceDone'\n\n  return val.type;\n}\n\nfunction writeResourceDone(buff, rdata) {\n  var pos = buff.tell();\n  buff.seek(rdata.pos);\n  buff.writeUInt16BE(pos - rdata.pos - 2);\n  buff.seek(pos);\n  return WRITE_RESOURCE_RECORD;\n}\n\nfunction writeIp(buff, val) {\n  //TODO XXX FIXME -- assert that address is of proper type\n  assertUndefined(val.address, 'A/AAAA record requires \"address\"');\n  val = ipaddr.parse(val.address).toByteArray();\n  val.forEach(function (b) {\n    buff.writeUInt8(b);\n  });\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeCname(buff, val, label_index) {\n  assertUndefined(val.data, 'NS/CNAME/PTR record requires \"data\"');\n  namePack(val.data, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n} // For <character-string> see: http://tools.ietf.org/html/rfc1035#section-3.3\n// For TXT: http://tools.ietf.org/html/rfc1035#section-3.3.14\n\n\nfunction writeTxt(buff, val) {\n  //TODO XXX FIXME -- split on max char string and loop\n  assertUndefined(val.data, 'TXT record requires \"data\"');\n\n  for (var i = 0, len = val.data.length; i < len; i++) {\n    var dataLen = Buffer.byteLength(val.data[i], 'utf8');\n    buff.writeUInt8(dataLen);\n    buff.write(val.data[i], dataLen, 'utf8');\n  }\n\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeMx(buff, val, label_index) {\n  assertUndefined(val.priority, 'MX record requires \"priority\"');\n  assertUndefined(val.exchange, 'MX record requires \"exchange\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  namePack(val.exchange, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n} // SRV: https://tools.ietf.org/html/rfc2782\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\n\n\nfunction writeSrv(buff, val, label_index) {\n  assertUndefined(val.priority, 'SRV record requires \"priority\"');\n  assertUndefined(val.weight, 'SRV record requires \"weight\"');\n  assertUndefined(val.port, 'SRV record requires \"port\"');\n  assertUndefined(val.target, 'SRV record requires \"target\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  buff.writeUInt16BE(val.weight & 0xFFFF);\n  buff.writeUInt16BE(val.port & 0xFFFF);\n  namePack(val.target, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeSoa(buff, val, label_index) {\n  assertUndefined(val.primary, 'SOA record requires \"primary\"');\n  assertUndefined(val.admin, 'SOA record requires \"admin\"');\n  assertUndefined(val.serial, 'SOA record requires \"serial\"');\n  assertUndefined(val.refresh, 'SOA record requires \"refresh\"');\n  assertUndefined(val.retry, 'SOA record requires \"retry\"');\n  assertUndefined(val.expiration, 'SOA record requires \"expiration\"');\n  assertUndefined(val.minimum, 'SOA record requires \"minimum\"');\n  namePack(val.primary, buff, label_index);\n  namePack(val.admin, buff, label_index);\n  buff.writeUInt32BE(val.serial & 0xFFFFFFFF);\n  buff.writeInt32BE(val.refresh & 0xFFFFFFFF);\n  buff.writeInt32BE(val.retry & 0xFFFFFFFF);\n  buff.writeInt32BE(val.expiration & 0xFFFFFFFF);\n  buff.writeInt32BE(val.minimum & 0xFFFFFFFF);\n  return WRITE_RESOURCE_DONE;\n} // http://tools.ietf.org/html/rfc3403#section-4.1\n\n\nfunction writeNaptr(buff, val, label_index) {\n  assertUndefined(val.order, 'NAPTR record requires \"order\"');\n  assertUndefined(val.preference, 'NAPTR record requires \"preference\"');\n  assertUndefined(val.flags, 'NAPTR record requires \"flags\"');\n  assertUndefined(val.service, 'NAPTR record requires \"service\"');\n  assertUndefined(val.regexp, 'NAPTR record requires \"regexp\"');\n  assertUndefined(val.replacement, 'NAPTR record requires \"replacement\"');\n  buff.writeUInt16BE(val.order & 0xFFFF);\n  buff.writeUInt16BE(val.preference & 0xFFFF);\n  buff.writeUInt8(val.flags.length);\n  buff.write(val.flags, val.flags.length, 'ascii');\n  buff.writeUInt8(val.service.length);\n  buff.write(val.service, val.service.length, 'ascii');\n  buff.writeUInt8(val.regexp.length);\n  buff.write(val.regexp, val.regexp.length, 'ascii');\n  namePack(val.replacement, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n} // https://tools.ietf.org/html/rfc6698\n\n\nfunction writeTlsa(buff, val) {\n  assertUndefined(val.usage, 'TLSA record requires \"usage\"');\n  assertUndefined(val.selector, 'TLSA record requires \"selector\"');\n  assertUndefined(val.matchingtype, 'TLSA record requires \"matchingtype\"');\n  assertUndefined(val.buff, 'TLSA record requires \"buff\"');\n  buff.writeUInt8(val.usage);\n  buff.writeUInt8(val.selector);\n  buff.writeUInt8(val.matchingtype);\n  buff.copy(val.buff);\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction makeEdns(packet) {\n  packet.edns = {\n    name: '',\n    type: consts.NAME_TO_QTYPE.OPT,\n    class: packet.payload,\n    options: [],\n    ttl: 0\n  };\n  packet.edns_options = packet.edns.options; // TODO: 'edns_options' is DEPRECATED!\n\n  packet.additional.push(packet.edns);\n  return WRITE_HEADER;\n}\n\nfunction writeOpt(buff, val) {\n  var opt;\n\n  for (var i = 0, len = val.options.length; i < len; i++) {\n    opt = val.options[i];\n    buff.writeUInt16BE(opt.code);\n    buff.writeUInt16BE(opt.data.length);\n    buff.copy(opt.data);\n  }\n\n  return WRITE_RESOURCE_DONE;\n}\n\nPacket.write = function (buff, packet) {\n  var state = WRITE_HEADER,\n      val,\n      section,\n      count,\n      rdata,\n      last_resource,\n      label_index = {};\n  buff = new BufferCursor(buff); // the existence of 'edns' in a packet indicates that a proper OPT record exists\n  // in 'additional' and that all of the other fields in packet (that are parsed by\n  // 'parseOpt') are properly set. If it does not exist, we assume that the user\n  // is requesting that we create one for them.\n\n  if (typeof packet.edns_version !== 'undefined' && typeof packet.edns === \"undefined\") state = makeEdns(packet); // TODO: this is unnecessarily inefficient. rewrite this using a\n  //       function table instead. (same for Packet.parse too).\n\n  while (true) {\n    try {\n      switch (state) {\n        case WRITE_HEADER:\n          state = writeHeader(buff, packet);\n          break;\n\n        case WRITE_TRUNCATE:\n          state = writeTruncate(buff, packet, section, last_resource);\n          break;\n\n        case WRITE_QUESTION:\n          state = writeQuestion(buff, packet.question[0], label_index);\n          section = 'answer';\n          count = 0;\n          break;\n\n        case WRITE_RESOURCE_RECORD:\n          last_resource = buff.tell();\n\n          if (packet[section].length == count) {\n            switch (section) {\n              case 'answer':\n                section = 'authority';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n\n              case 'authority':\n                section = 'additional';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n\n              case 'additional':\n                state = WRITE_END;\n                break;\n            }\n\n            count = 0;\n          } else {\n            state = WRITE_RESOURCE_WRITE;\n          }\n\n          break;\n\n        case WRITE_RESOURCE_WRITE:\n          rdata = {};\n          val = packet[section][count];\n          state = writeResource(buff, val, label_index, rdata);\n          break;\n\n        case WRITE_RESOURCE_DONE:\n          count += 1;\n          state = writeResourceDone(buff, rdata);\n          break;\n\n        case WRITE_A:\n        case WRITE_AAAA:\n          state = writeIp(buff, val);\n          break;\n\n        case WRITE_NS:\n        case WRITE_CNAME:\n        case WRITE_PTR:\n          state = writeCname(buff, val, label_index);\n          break;\n\n        case WRITE_SPF:\n        case WRITE_TXT:\n          state = writeTxt(buff, val);\n          break;\n\n        case WRITE_MX:\n          state = writeMx(buff, val, label_index);\n          break;\n\n        case WRITE_SRV:\n          state = writeSrv(buff, val, label_index);\n          break;\n\n        case WRITE_SOA:\n          state = writeSoa(buff, val, label_index);\n          break;\n\n        case WRITE_OPT:\n          state = writeOpt(buff, val);\n          break;\n\n        case WRITE_NAPTR:\n          state = writeNaptr(buff, val, label_index);\n          break;\n\n        case WRITE_TLSA:\n          state = writeTlsa(buff, val);\n          break;\n\n        case WRITE_END:\n          return buff.tell();\n\n        default:\n          if (typeof val.data !== 'object') throw new Error('Packet.write Unknown State: ' + state); // write unhandled RR type\n\n          buff.copy(val.data);\n          state = WRITE_RESOURCE_DONE;\n      }\n    } catch (e) {\n      if (e instanceof BufferCursorOverflow) {\n        state = WRITE_TRUNCATE;\n      } else {\n        throw e;\n      }\n    }\n  }\n};\n\nfunction parseHeader(msg, packet) {\n  packet.header.id = msg.readUInt16BE();\n  var val = msg.readUInt16BE();\n  packet.header.qr = (val & 0x8000) >> 15;\n  packet.header.opcode = (val & 0x7800) >> 11;\n  packet.header.aa = (val & 0x400) >> 10;\n  packet.header.tc = (val & 0x200) >> 9;\n  packet.header.rd = (val & 0x100) >> 8;\n  packet.header.ra = (val & 0x80) >> 7;\n  packet.header.res1 = (val & 0x40) >> 6;\n  packet.header.res2 = (val & 0x20) >> 5;\n  packet.header.res3 = (val & 0x10) >> 4;\n  packet.header.rcode = val & 0xF;\n  packet.question = new Array(msg.readUInt16BE());\n  packet.answer = new Array(msg.readUInt16BE());\n  packet.authority = new Array(msg.readUInt16BE());\n  packet.additional = new Array(msg.readUInt16BE());\n  return PARSE_QUESTION;\n}\n\nfunction parseQuestion(msg, packet) {\n  var val = {};\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  packet.question[0] = val;\n  assert(packet.question.length === 1); // TODO handle qdcount > 1 in practice no one sends this\n\n  return PARSE_RESOURCE_RECORD;\n}\n\nfunction parseRR(msg, val, rdata) {\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  val.ttl = msg.readUInt32BE();\n  rdata.len = msg.readUInt16BE();\n  return val.type;\n}\n\nfunction parseA(val, msg) {\n  var address = '' + msg.readUInt8() + '.' + msg.readUInt8() + '.' + msg.readUInt8() + '.' + msg.readUInt8();\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseAAAA(val, msg) {\n  var address = '';\n  var compressed = false;\n\n  for (var i = 0; i < 8; i++) {\n    if (i > 0) address += ':'; // TODO zero compression\n\n    address += msg.readUInt16BE().toString(16);\n  }\n\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseCname(val, msg) {\n  val.data = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseTxt(val, msg, rdata) {\n  val.data = [];\n  var end = msg.tell() + rdata.len;\n\n  while (msg.tell() != end) {\n    var len = msg.readUInt8();\n    val.data.push(msg.toString('utf8', len));\n  }\n\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseMx(val, msg, rdata) {\n  val.priority = msg.readUInt16BE();\n  val.exchange = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n} // TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\n//       https://tools.ietf.org/html/rfc2782\n\n\nfunction parseSrv(val, msg) {\n  val.priority = msg.readUInt16BE();\n  val.weight = msg.readUInt16BE();\n  val.port = msg.readUInt16BE();\n  val.target = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseSoa(val, msg) {\n  val.primary = nameUnpack(msg);\n  val.admin = nameUnpack(msg);\n  val.serial = msg.readUInt32BE();\n  val.refresh = msg.readInt32BE();\n  val.retry = msg.readInt32BE();\n  val.expiration = msg.readInt32BE();\n  val.minimum = msg.readInt32BE();\n  return PARSE_RESOURCE_DONE;\n} // http://tools.ietf.org/html/rfc3403#section-4.1\n\n\nfunction parseNaptr(val, msg) {\n  val.order = msg.readUInt16BE();\n  val.preference = msg.readUInt16BE();\n  var len = msg.readUInt8();\n  val.flags = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.service = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.regexp = msg.toString('ascii', len);\n  val.replacement = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseTlsa(val, msg, rdata) {\n  val.usage = msg.readUInt8();\n  val.selector = msg.readUInt8();\n  val.matchingtype = msg.readUInt8();\n  val.buff = msg.slice(rdata.len - 3).buffer; // 3 because of the 3 UInt8s above.\n\n  return PARSE_RESOURCE_DONE;\n} // https://tools.ietf.org/html/rfc6891#section-6.1.2\n// https://tools.ietf.org/html/rfc2671#section-4.4\n//       - [payload size selection](https://tools.ietf.org/html/rfc6891#section-6.2.5)\n\n\nfunction parseOpt(val, msg, rdata, packet) {\n  // assert first entry in additional\n  rdata.buf = msg.slice(rdata.len);\n  val.rcode = ((val.ttl & 0xFF000000) >> 20) + packet.header.rcode;\n  val.version = val.ttl >> 16 & 0xFF;\n  val.do = val.ttl >> 15 & 1;\n  val.z = val.ttl & 0x7F;\n  val.options = [];\n  packet.edns = val;\n  packet.edns_version = val.version; // TODO: return BADVERS for unsupported version! (Section 6.1.3)\n  // !! BEGIN DEPRECATION NOTICE !!\n  // THESE FIELDS MAY BE REMOVED IN THE FUTURE!\n\n  packet.edns_options = val.options;\n  packet.payload = val.class; // !! END DEPRECATION NOTICE !!\n\n  while (!rdata.buf.eof()) {\n    val.options.push({\n      code: rdata.buf.readUInt16BE(),\n      data: rdata.buf.slice(rdata.buf.readUInt16BE()).buffer\n    });\n  }\n\n  return PARSE_RESOURCE_DONE;\n}\n\nvar PARSE_HEADER = 100000,\n    PARSE_QUESTION = 100001,\n    PARSE_RESOURCE_RECORD = 100002,\n    PARSE_RR_UNPACK = 100003,\n    PARSE_RESOURCE_DONE = 100004,\n    PARSE_END = 100005,\n    PARSE_A = consts.NAME_TO_QTYPE.A,\n    PARSE_NS = consts.NAME_TO_QTYPE.NS,\n    PARSE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n    PARSE_SOA = consts.NAME_TO_QTYPE.SOA,\n    PARSE_PTR = consts.NAME_TO_QTYPE.PTR,\n    PARSE_MX = consts.NAME_TO_QTYPE.MX,\n    PARSE_TXT = consts.NAME_TO_QTYPE.TXT,\n    PARSE_AAAA = consts.NAME_TO_QTYPE.AAAA,\n    PARSE_SRV = consts.NAME_TO_QTYPE.SRV,\n    PARSE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n    PARSE_OPT = consts.NAME_TO_QTYPE.OPT,\n    PARSE_SPF = consts.NAME_TO_QTYPE.SPF,\n    PARSE_TLSA = consts.NAME_TO_QTYPE.TLSA;\n\nPacket.parse = function (msg) {\n  var state, pos, val, rdata, section, count;\n  var packet = new Packet();\n  pos = 0;\n  state = PARSE_HEADER;\n  msg = new BufferCursor(msg);\n\n  while (true) {\n    switch (state) {\n      case PARSE_HEADER:\n        state = parseHeader(msg, packet);\n        break;\n\n      case PARSE_QUESTION:\n        state = parseQuestion(msg, packet);\n        section = 'answer';\n        count = 0;\n        break;\n\n      case PARSE_RESOURCE_RECORD:\n        // console.log('PARSE_RESOURCE_RECORD: count = %d, %s.len = %d', count, section, packet[section].length);\n        if (count === packet[section].length) {\n          switch (section) {\n            case 'answer':\n              section = 'authority';\n              count = 0;\n              break;\n\n            case 'authority':\n              section = 'additional';\n              count = 0;\n              break;\n\n            case 'additional':\n              state = PARSE_END;\n              break;\n          }\n        } else {\n          state = PARSE_RR_UNPACK;\n        }\n\n        break;\n\n      case PARSE_RR_UNPACK:\n        val = {};\n        rdata = {};\n        state = parseRR(msg, val, rdata);\n        break;\n\n      case PARSE_RESOURCE_DONE:\n        packet[section][count++] = val;\n        state = PARSE_RESOURCE_RECORD;\n        break;\n\n      case PARSE_A:\n        state = parseA(val, msg);\n        break;\n\n      case PARSE_AAAA:\n        state = parseAAAA(val, msg);\n        break;\n\n      case PARSE_NS:\n      case PARSE_CNAME:\n      case PARSE_PTR:\n        state = parseCname(val, msg);\n        break;\n\n      case PARSE_SPF:\n      case PARSE_TXT:\n        state = parseTxt(val, msg, rdata);\n        break;\n\n      case PARSE_MX:\n        state = parseMx(val, msg);\n        break;\n\n      case PARSE_SRV:\n        state = parseSrv(val, msg);\n        break;\n\n      case PARSE_SOA:\n        state = parseSoa(val, msg);\n        break;\n\n      case PARSE_OPT:\n        state = parseOpt(val, msg, rdata, packet);\n        break;\n\n      case PARSE_NAPTR:\n        state = parseNaptr(val, msg);\n        break;\n\n      case PARSE_TLSA:\n        state = parseTlsa(val, msg, rdata);\n        break;\n\n      case PARSE_END:\n        return packet;\n\n      default:\n        //console.log(state, val);\n        val.data = msg.slice(rdata.len);\n        state = PARSE_RESOURCE_DONE;\n        break;\n    }\n  }\n};","map":{"version":3,"names":["consts","require","BufferCursor","BufferCursorOverflow","ipaddr","assert","util","assertUndefined","val","msg","Packet","module","exports","header","id","qr","opcode","aa","tc","rd","ra","res1","res2","res3","rcode","question","answer","authority","additional","edns_options","payload","undefined","LABEL_POINTER","isPointer","len","nameUnpack","buff","comp","end","pos","part","combine","readUInt8","tell","seek","toString","length","namePack","str","index","offset","dot","writeUInt16BE","indexOf","slice","writeUInt8","write","WRITE_HEADER","WRITE_TRUNCATE","WRITE_QUESTION","WRITE_RESOURCE_RECORD","WRITE_RESOURCE_WRITE","WRITE_RESOURCE_DONE","WRITE_RESOURCE_END","WRITE_EDNS","WRITE_END","WRITE_A","NAME_TO_QTYPE","A","WRITE_AAAA","AAAA","WRITE_NS","NS","WRITE_CNAME","CNAME","WRITE_PTR","PTR","WRITE_SPF","SPF","WRITE_MX","MX","WRITE_SRV","SRV","WRITE_TXT","TXT","WRITE_SOA","SOA","WRITE_OPT","OPT","WRITE_NAPTR","NAPTR","WRITE_TLSA","TLSA","writeHeader","packet","writeTruncate","section","readUInt16BE","count","last_resource","writeQuestion","label_index","name","type","class","writeResource","rdata","ttl","writeUInt32BE","writeResourceDone","writeIp","address","parse","toByteArray","forEach","b","writeCname","data","writeTxt","i","dataLen","Buffer","byteLength","writeMx","priority","exchange","writeSrv","weight","port","target","writeSoa","primary","admin","serial","refresh","retry","expiration","minimum","writeInt32BE","writeNaptr","order","preference","flags","service","regexp","replacement","writeTlsa","usage","selector","matchingtype","copy","makeEdns","edns","options","push","writeOpt","opt","code","state","edns_version","Error","e","parseHeader","Array","PARSE_QUESTION","parseQuestion","PARSE_RESOURCE_RECORD","parseRR","readUInt32BE","parseA","PARSE_RESOURCE_DONE","parseAAAA","compressed","parseCname","parseTxt","parseMx","parseSrv","parseSoa","readInt32BE","parseNaptr","parseTlsa","buffer","parseOpt","buf","version","do","z","eof","PARSE_HEADER","PARSE_RR_UNPACK","PARSE_END","PARSE_A","PARSE_NS","PARSE_CNAME","PARSE_SOA","PARSE_PTR","PARSE_MX","PARSE_TXT","PARSE_AAAA","PARSE_SRV","PARSE_NAPTR","PARSE_OPT","PARSE_SPF","PARSE_TLSA"],"sources":["C:/Users/Kamen/ML/AlgoTrader/node_modules/native-dns-packet/packet.js"],"sourcesContent":["// Copyright 2011 Timothy J Fontaine <tjfontaine@gmail.com>\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the 'Software'), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE\r\n\r\n// TODO: change the default UDP packet size that node-dns sends\r\n//       from 4096 to conform to these:\r\n//       - [requestor's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.3)\r\n//       - [responders's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.4)\r\n\r\n'use strict';\r\n\r\nvar consts = require('./consts'),\r\n    BufferCursor = require('buffercursor'),\r\n    BufferCursorOverflow = BufferCursor.BufferCursorOverflow,\r\n    ipaddr = require('ipaddr.js'),\r\n    assert = require('assert'),\r\n    util = require('util');\r\n\r\nfunction assertUndefined(val, msg) {\r\n  assert(typeof val != 'undefined', msg);\r\n}\r\n\r\nvar Packet = module.exports = function() {\r\n  this.header = {\r\n    id: 0,\r\n    qr: 0,\r\n    opcode: 0,\r\n    aa: 0,\r\n    tc: 0,\r\n    rd: 1,\r\n    ra: 0,\r\n    res1: 0,\r\n    res2: 0,\r\n    res3: 0,\r\n    rcode: 0\r\n  };\r\n  this.question = [];\r\n  this.answer = [];\r\n  this.authority = [];\r\n  this.additional = [];\r\n  this.edns_options = [];   // TODO: DEPRECATED! Use `.edns.options` instead!\r\n  this.payload = undefined; // TODO: DEPRECATED! Use `.edns.payload` instead!\r\n};\r\n\r\nvar LABEL_POINTER = 0xC0;\r\n\r\nvar isPointer = function(len) {\r\n  return (len & LABEL_POINTER) === LABEL_POINTER;\r\n};\r\n\r\nfunction nameUnpack(buff) {\r\n  var len, comp, end, pos, part, combine = '';\r\n\r\n  len = buff.readUInt8();\r\n  comp = false;\r\n  end = buff.tell();\r\n\r\n  while (len !== 0) {\r\n    if (isPointer(len)) {\r\n      len -= LABEL_POINTER;\r\n      len = len << 8;\r\n      pos = len + buff.readUInt8();\r\n      if (!comp)\r\n        end = buff.tell();\r\n      buff.seek(pos);\r\n      len = buff.readUInt8();\r\n      comp = true;\r\n      continue;\r\n    }\r\n\r\n    part = buff.toString('ascii', len);\r\n\r\n    if (combine.length)\r\n      combine = combine + '.' + part;\r\n    else\r\n      combine = part;\r\n\r\n    len = buff.readUInt8();\r\n\r\n    if (!comp)\r\n      end = buff.tell();\r\n  }\r\n\r\n  buff.seek(end);\r\n\r\n  return combine;\r\n}\r\n\r\nfunction namePack(str, buff, index) {\r\n  var offset, dot, part;\r\n\r\n  while (str) {\r\n    if (index[str]) {\r\n      offset = (LABEL_POINTER << 8) + index[str];\r\n      buff.writeUInt16BE(offset);\r\n      break;\r\n    } else {\r\n      index[str] = buff.tell();\r\n      dot = str.indexOf('.');\r\n      if (dot > -1) {\r\n        part = str.slice(0, dot);\r\n        str = str.slice(dot + 1);\r\n      } else {\r\n        part = str;\r\n        str = undefined;\r\n      }\r\n      buff.writeUInt8(part.length);\r\n      buff.write(part, part.length, 'ascii');\r\n    }\r\n  }\r\n\r\n  if (!str) {\r\n    buff.writeUInt8(0);\r\n  }\r\n}\r\n\r\nvar\r\n  WRITE_HEADER              = 100001,\r\n  WRITE_TRUNCATE            = 100002,\r\n  WRITE_QUESTION            = 100003,\r\n  WRITE_RESOURCE_RECORD     = 100004,\r\n  WRITE_RESOURCE_WRITE      = 100005,\r\n  WRITE_RESOURCE_DONE       = 100006,\r\n  WRITE_RESOURCE_END        = 100007,\r\n  WRITE_EDNS                = 100008,\r\n  WRITE_END                 = 100009,\r\n  WRITE_A     = consts.NAME_TO_QTYPE.A,\r\n  WRITE_AAAA  = consts.NAME_TO_QTYPE.AAAA,\r\n  WRITE_NS    = consts.NAME_TO_QTYPE.NS,\r\n  WRITE_CNAME = consts.NAME_TO_QTYPE.CNAME,\r\n  WRITE_PTR   = consts.NAME_TO_QTYPE.PTR,\r\n  WRITE_SPF   = consts.NAME_TO_QTYPE.SPF,\r\n  WRITE_MX    = consts.NAME_TO_QTYPE.MX,\r\n  WRITE_SRV   = consts.NAME_TO_QTYPE.SRV,\r\n  WRITE_TXT   = consts.NAME_TO_QTYPE.TXT,\r\n  WRITE_SOA   = consts.NAME_TO_QTYPE.SOA,\r\n  WRITE_OPT   = consts.NAME_TO_QTYPE.OPT,\r\n  WRITE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\r\n  WRITE_TLSA  = consts.NAME_TO_QTYPE.TLSA;\r\n\r\nfunction writeHeader(buff, packet) {\r\n  assert(packet.header, 'Packet requires \"header\"');\r\n  buff.writeUInt16BE(packet.header.id & 0xFFFF);\r\n  var val = 0;\r\n  val += (packet.header.qr << 15) & 0x8000;\r\n  val += (packet.header.opcode << 11) & 0x7800;\r\n  val += (packet.header.aa << 10) & 0x400;\r\n  val += (packet.header.tc << 9) & 0x200;\r\n  val += (packet.header.rd << 8) & 0x100;\r\n  val += (packet.header.ra << 7) & 0x80;\r\n  val += (packet.header.res1 << 6) & 0x40;\r\n  val += (packet.header.res2 << 5) & 0x20;\r\n  val += (packet.header.res3 << 4) & 0x10;\r\n  val += packet.header.rcode & 0xF;\r\n  buff.writeUInt16BE(val & 0xFFFF);\r\n  assert(packet.question.length == 1, 'DNS requires one question');\r\n  // aren't used\r\n  buff.writeUInt16BE(1);\r\n  // answer offset 6\r\n  buff.writeUInt16BE(packet.answer.length & 0xFFFF);\r\n  // authority offset 8\r\n  buff.writeUInt16BE(packet.authority.length & 0xFFFF);\r\n  // additional offset 10\r\n  buff.writeUInt16BE(packet.additional.length & 0xFFFF);\r\n  return WRITE_QUESTION;\r\n}\r\n\r\nfunction writeTruncate(buff, packet, section, val) {\r\n  // XXX FIXME TODO truncation is currently done wrong.\r\n  // Quote rfc2181 section 9\r\n  // The TC bit should not be set merely because some extra information\r\n  // could have been included, but there was insufficient room.  This\r\n  // includes the results of additional section processing.  In such cases\r\n  // the entire RRSet that will not fit in the response should be omitted,\r\n  // and the reply sent as is, with the TC bit clear.  If the recipient of\r\n  // the reply needs the omitted data, it can construct a query for that\r\n  // data and send that separately.\r\n  //\r\n  // TODO IOW only set TC if we hit it in ANSWERS otherwise make sure an\r\n  // entire RRSet is removed during a truncation.\r\n  var pos;\r\n\r\n  buff.seek(2);\r\n  val = buff.readUInt16BE();\r\n  val |= (1 << 9) & 0x200;\r\n  buff.seek(2);\r\n  buff.writeUInt16BE(val);\r\n  switch (section) {\r\n    case 'answer':\r\n      pos = 6;\r\n      // seek to authority and clear it and additional out\r\n      buff.seek(8);\r\n      buff.writeUInt16BE(0);\r\n      buff.writeUInt16BE(0);\r\n      break;\r\n    case 'authority':\r\n      pos = 8;\r\n      // seek to additional and clear it out\r\n      buff.seek(10);\r\n      buff.writeUInt16BE(0);\r\n      break;\r\n    case 'additional':\r\n      pos = 10;\r\n      break;\r\n  }\r\n  buff.seek(pos);\r\n  buff.writeUInt16BE(count - 1); // TODO: count not defined!\r\n  buff.seek(last_resource);      // TODO: last_resource not defined!\r\n  return WRITE_END;\r\n}\r\n\r\nfunction writeQuestion(buff, val, label_index) {\r\n  assert(val, 'Packet requires a question');\r\n  assertUndefined(val.name, 'Question requires a \"name\"');\r\n  assertUndefined(val.type, 'Question requires a \"type\"');\r\n  assertUndefined(val.class, 'Questionn requires a \"class\"');\r\n  namePack(val.name, buff, label_index);\r\n  buff.writeUInt16BE(val.type & 0xFFFF);\r\n  buff.writeUInt16BE(val.class & 0xFFFF);\r\n  return WRITE_RESOURCE_RECORD;\r\n}\r\n\r\nfunction writeResource(buff, val, label_index, rdata) {\r\n  assert(val, 'Resource must be defined');\r\n  assertUndefined(val.name, 'Resource record requires \"name\"');\r\n  assertUndefined(val.type, 'Resource record requires \"type\"');\r\n  assertUndefined(val.class, 'Resource record requires \"class\"');\r\n  assertUndefined(val.ttl, 'Resource record requires \"ttl\"');\r\n  namePack(val.name, buff, label_index);\r\n  buff.writeUInt16BE(val.type & 0xFFFF);\r\n  buff.writeUInt16BE(val.class & 0xFFFF);\r\n  buff.writeUInt32BE(val.ttl & 0xFFFFFFFF);\r\n  rdata.pos = buff.tell();\r\n  buff.writeUInt16BE(0); // if there is rdata, then this value will be updated\r\n                         // to the correct value by 'writeResourceDone'\r\n  return val.type;\r\n}\r\n\r\nfunction writeResourceDone(buff, rdata) {\r\n  var pos = buff.tell();\r\n  buff.seek(rdata.pos);\r\n  buff.writeUInt16BE(pos - rdata.pos - 2);\r\n  buff.seek(pos);\r\n  return WRITE_RESOURCE_RECORD;\r\n}\r\n\r\nfunction writeIp(buff, val) {\r\n  //TODO XXX FIXME -- assert that address is of proper type\r\n  assertUndefined(val.address, 'A/AAAA record requires \"address\"');\r\n  val = ipaddr.parse(val.address).toByteArray();\r\n  val.forEach(function(b) {\r\n    buff.writeUInt8(b);\r\n  });\r\n  return WRITE_RESOURCE_DONE;\r\n}\r\n\r\nfunction writeCname(buff, val, label_index) {\r\n  assertUndefined(val.data, 'NS/CNAME/PTR record requires \"data\"');\r\n  namePack(val.data, buff, label_index);\r\n  return WRITE_RESOURCE_DONE;\r\n}\r\n\r\n// For <character-string> see: http://tools.ietf.org/html/rfc1035#section-3.3\r\n// For TXT: http://tools.ietf.org/html/rfc1035#section-3.3.14\r\nfunction writeTxt(buff, val) {\r\n  //TODO XXX FIXME -- split on max char string and loop\r\n  assertUndefined(val.data, 'TXT record requires \"data\"');\r\n  for (var i=0,len=val.data.length; i<len; i++) {\r\n    var dataLen = Buffer.byteLength(val.data[i], 'utf8');\r\n    buff.writeUInt8(dataLen);\r\n    buff.write(val.data[i], dataLen, 'utf8');\r\n  }\r\n  return WRITE_RESOURCE_DONE;\r\n}\r\n\r\nfunction writeMx(buff, val, label_index) {\r\n  assertUndefined(val.priority, 'MX record requires \"priority\"');\r\n  assertUndefined(val.exchange, 'MX record requires \"exchange\"');\r\n  buff.writeUInt16BE(val.priority & 0xFFFF);\r\n  namePack(val.exchange, buff, label_index);\r\n  return WRITE_RESOURCE_DONE;\r\n}\r\n\r\n// SRV: https://tools.ietf.org/html/rfc2782\r\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\r\nfunction writeSrv(buff, val, label_index) {\r\n  assertUndefined(val.priority, 'SRV record requires \"priority\"');\r\n  assertUndefined(val.weight, 'SRV record requires \"weight\"');\r\n  assertUndefined(val.port, 'SRV record requires \"port\"');\r\n  assertUndefined(val.target, 'SRV record requires \"target\"');\r\n  buff.writeUInt16BE(val.priority & 0xFFFF);\r\n  buff.writeUInt16BE(val.weight & 0xFFFF);\r\n  buff.writeUInt16BE(val.port & 0xFFFF);\r\n  namePack(val.target, buff, label_index);\r\n  return WRITE_RESOURCE_DONE;\r\n}\r\n\r\nfunction writeSoa(buff, val, label_index) {\r\n  assertUndefined(val.primary, 'SOA record requires \"primary\"');\r\n  assertUndefined(val.admin, 'SOA record requires \"admin\"');\r\n  assertUndefined(val.serial, 'SOA record requires \"serial\"');\r\n  assertUndefined(val.refresh, 'SOA record requires \"refresh\"');\r\n  assertUndefined(val.retry, 'SOA record requires \"retry\"');\r\n  assertUndefined(val.expiration, 'SOA record requires \"expiration\"');\r\n  assertUndefined(val.minimum, 'SOA record requires \"minimum\"');\r\n  namePack(val.primary, buff, label_index);\r\n  namePack(val.admin, buff, label_index);\r\n  buff.writeUInt32BE(val.serial & 0xFFFFFFFF);\r\n  buff.writeInt32BE(val.refresh & 0xFFFFFFFF);\r\n  buff.writeInt32BE(val.retry & 0xFFFFFFFF);\r\n  buff.writeInt32BE(val.expiration & 0xFFFFFFFF);\r\n  buff.writeInt32BE(val.minimum & 0xFFFFFFFF);\r\n  return WRITE_RESOURCE_DONE;\r\n}\r\n\r\n// http://tools.ietf.org/html/rfc3403#section-4.1\r\nfunction writeNaptr(buff, val, label_index) {\r\n  assertUndefined(val.order, 'NAPTR record requires \"order\"');\r\n  assertUndefined(val.preference, 'NAPTR record requires \"preference\"');\r\n  assertUndefined(val.flags, 'NAPTR record requires \"flags\"');\r\n  assertUndefined(val.service, 'NAPTR record requires \"service\"');\r\n  assertUndefined(val.regexp, 'NAPTR record requires \"regexp\"');\r\n  assertUndefined(val.replacement, 'NAPTR record requires \"replacement\"');\r\n  buff.writeUInt16BE(val.order & 0xFFFF);\r\n  buff.writeUInt16BE(val.preference & 0xFFFF);\r\n  buff.writeUInt8(val.flags.length);\r\n  buff.write(val.flags, val.flags.length, 'ascii');\r\n  buff.writeUInt8(val.service.length);\r\n  buff.write(val.service, val.service.length, 'ascii');\r\n  buff.writeUInt8(val.regexp.length);\r\n  buff.write(val.regexp, val.regexp.length, 'ascii');\r\n  namePack(val.replacement, buff, label_index);\r\n  return WRITE_RESOURCE_DONE;\r\n}\r\n\r\n// https://tools.ietf.org/html/rfc6698\r\nfunction writeTlsa(buff, val) {\r\n  assertUndefined(val.usage, 'TLSA record requires \"usage\"');\r\n  assertUndefined(val.selector, 'TLSA record requires \"selector\"');\r\n  assertUndefined(val.matchingtype, 'TLSA record requires \"matchingtype\"');\r\n  assertUndefined(val.buff, 'TLSA record requires \"buff\"');\r\n  buff.writeUInt8(val.usage);\r\n  buff.writeUInt8(val.selector);\r\n  buff.writeUInt8(val.matchingtype);\r\n  buff.copy(val.buff);\r\n  return WRITE_RESOURCE_DONE;\r\n}\r\n\r\nfunction makeEdns(packet) {\r\n  packet.edns = {\r\n    name: '',\r\n    type: consts.NAME_TO_QTYPE.OPT,\r\n    class: packet.payload,\r\n    options: [],\r\n    ttl: 0\r\n  };\r\n  packet.edns_options = packet.edns.options; // TODO: 'edns_options' is DEPRECATED!\r\n  packet.additional.push(packet.edns);\r\n  return WRITE_HEADER;\r\n}\r\n\r\nfunction writeOpt(buff, val) {\r\n  var opt;\r\n  for (var i=0, len=val.options.length; i<len; i++) {\r\n    opt = val.options[i];\r\n    buff.writeUInt16BE(opt.code);\r\n    buff.writeUInt16BE(opt.data.length);\r\n    buff.copy(opt.data);\r\n  }\r\n  return WRITE_RESOURCE_DONE;\r\n}\r\n\r\nPacket.write = function(buff, packet) {\r\n  var state = WRITE_HEADER,\r\n      val,\r\n      section,\r\n      count,\r\n      rdata,\r\n      last_resource,\r\n      label_index = {};\r\n\r\n  buff = new BufferCursor(buff);\r\n\r\n  // the existence of 'edns' in a packet indicates that a proper OPT record exists\r\n  // in 'additional' and that all of the other fields in packet (that are parsed by\r\n  // 'parseOpt') are properly set. If it does not exist, we assume that the user\r\n  // is requesting that we create one for them.\r\n  if (typeof packet.edns_version !== 'undefined' && typeof packet.edns === \"undefined\")\r\n    state = makeEdns(packet);\r\n\r\n  // TODO: this is unnecessarily inefficient. rewrite this using a\r\n  //       function table instead. (same for Packet.parse too).\r\n  while (true) {\r\n    try {\r\n      switch (state) {\r\n        case WRITE_HEADER:\r\n          state = writeHeader(buff, packet);\r\n          break;\r\n        case WRITE_TRUNCATE:\r\n          state = writeTruncate(buff, packet, section, last_resource);\r\n          break;\r\n        case WRITE_QUESTION:\r\n          state = writeQuestion(buff, packet.question[0], label_index);\r\n          section = 'answer';\r\n          count = 0;\r\n          break;\r\n        case WRITE_RESOURCE_RECORD:\r\n          last_resource = buff.tell();\r\n          if (packet[section].length == count) {\r\n            switch (section) {\r\n              case 'answer':\r\n                section = 'authority';\r\n                state = WRITE_RESOURCE_RECORD;\r\n                break;\r\n              case 'authority':\r\n                section = 'additional';\r\n                state = WRITE_RESOURCE_RECORD;\r\n                break;\r\n              case 'additional':\r\n                state = WRITE_END;\r\n                break;\r\n            }\r\n            count = 0;\r\n          } else {\r\n            state = WRITE_RESOURCE_WRITE;\r\n          }\r\n          break;\r\n        case WRITE_RESOURCE_WRITE:\r\n          rdata = {};\r\n          val = packet[section][count];\r\n          state = writeResource(buff, val, label_index, rdata);\r\n          break;\r\n        case WRITE_RESOURCE_DONE:\r\n          count += 1;\r\n          state = writeResourceDone(buff, rdata);\r\n          break;\r\n        case WRITE_A:\r\n        case WRITE_AAAA:\r\n          state = writeIp(buff, val);\r\n          break;\r\n        case WRITE_NS:\r\n        case WRITE_CNAME:\r\n        case WRITE_PTR:\r\n          state = writeCname(buff, val, label_index);\r\n          break;\r\n        case WRITE_SPF:\r\n        case WRITE_TXT:\r\n          state = writeTxt(buff, val);\r\n          break;\r\n        case WRITE_MX:\r\n          state = writeMx(buff, val, label_index);\r\n          break;\r\n        case WRITE_SRV:\r\n          state = writeSrv(buff, val, label_index);\r\n          break;\r\n        case WRITE_SOA:\r\n          state = writeSoa(buff, val, label_index);\r\n          break;\r\n        case WRITE_OPT:\r\n          state = writeOpt(buff, val);\r\n          break;\r\n        case WRITE_NAPTR:\r\n          state = writeNaptr(buff, val, label_index);\r\n          break;\r\n        case WRITE_TLSA:\r\n          state = writeTlsa(buff, val);\r\n          break;\r\n        case WRITE_END:\r\n          return buff.tell();\r\n        default:\r\n          if (typeof val.data !== 'object')\r\n            throw new Error('Packet.write Unknown State: ' + state);\r\n          // write unhandled RR type\r\n          buff.copy(val.data);\r\n          state = WRITE_RESOURCE_DONE;\r\n      }\r\n    } catch (e) {\r\n      if (e instanceof BufferCursorOverflow) {\r\n        state = WRITE_TRUNCATE;\r\n      } else {\r\n        throw e;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nfunction parseHeader(msg, packet) {\r\n  packet.header.id = msg.readUInt16BE();\r\n  var val = msg.readUInt16BE();\r\n  packet.header.qr = (val & 0x8000) >> 15;\r\n  packet.header.opcode = (val & 0x7800) >> 11;\r\n  packet.header.aa = (val & 0x400) >> 10;\r\n  packet.header.tc = (val & 0x200) >> 9;\r\n  packet.header.rd = (val & 0x100) >> 8;\r\n  packet.header.ra = (val & 0x80) >> 7;\r\n  packet.header.res1 = (val & 0x40) >> 6;\r\n  packet.header.res2 = (val & 0x20) >> 5;\r\n  packet.header.res3 = (val & 0x10) >> 4;\r\n  packet.header.rcode = (val & 0xF);\r\n  packet.question = new Array(msg.readUInt16BE());\r\n  packet.answer = new Array(msg.readUInt16BE());\r\n  packet.authority = new Array(msg.readUInt16BE());\r\n  packet.additional = new Array(msg.readUInt16BE());\r\n  return PARSE_QUESTION;\r\n}\r\n\r\nfunction parseQuestion(msg, packet) {\r\n  var val = {};\r\n  val.name = nameUnpack(msg);\r\n  val.type = msg.readUInt16BE();\r\n  val.class = msg.readUInt16BE();\r\n  packet.question[0] = val;\r\n  assert(packet.question.length === 1);\r\n  // TODO handle qdcount > 1 in practice no one sends this\r\n  return PARSE_RESOURCE_RECORD;\r\n}\r\n\r\nfunction parseRR(msg, val, rdata) {\r\n  val.name = nameUnpack(msg);\r\n  val.type = msg.readUInt16BE();\r\n  val.class = msg.readUInt16BE();\r\n  val.ttl = msg.readUInt32BE();\r\n  rdata.len = msg.readUInt16BE();\r\n  return val.type;\r\n}\r\n\r\nfunction parseA(val, msg) {\r\n  var address = '' +\r\n    msg.readUInt8() +\r\n    '.' + msg.readUInt8() +\r\n    '.' + msg.readUInt8() +\r\n    '.' + msg.readUInt8();\r\n  val.address = address;\r\n  return PARSE_RESOURCE_DONE;\r\n}\r\n\r\nfunction parseAAAA(val, msg) {\r\n  var address = '';\r\n  var compressed = false;\r\n\r\n  for (var i = 0; i < 8; i++) {\r\n    if (i > 0) address += ':';\r\n    // TODO zero compression\r\n    address += msg.readUInt16BE().toString(16);\r\n  }\r\n  val.address = address;\r\n  return PARSE_RESOURCE_DONE;\r\n}\r\n\r\nfunction parseCname(val, msg) {\r\n  val.data = nameUnpack(msg);\r\n  return PARSE_RESOURCE_DONE;\r\n}\r\n\r\nfunction parseTxt(val, msg, rdata) {\r\n  val.data = [];\r\n  var end = msg.tell() + rdata.len;\r\n  while (msg.tell() != end) {\r\n    var len = msg.readUInt8();\r\n    val.data.push(msg.toString('utf8', len));\r\n  }\r\n  return PARSE_RESOURCE_DONE;\r\n}\r\n\r\nfunction parseMx(val, msg, rdata) {\r\n  val.priority = msg.readUInt16BE();\r\n  val.exchange = nameUnpack(msg);\r\n  return PARSE_RESOURCE_DONE;\r\n}\r\n\r\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\r\n//       https://tools.ietf.org/html/rfc2782\r\nfunction parseSrv(val, msg) {\r\n  val.priority = msg.readUInt16BE();\r\n  val.weight = msg.readUInt16BE();\r\n  val.port = msg.readUInt16BE();\r\n  val.target = nameUnpack(msg);\r\n  return PARSE_RESOURCE_DONE;\r\n}\r\n\r\nfunction parseSoa(val, msg) {\r\n  val.primary = nameUnpack(msg);\r\n  val.admin = nameUnpack(msg);\r\n  val.serial = msg.readUInt32BE();\r\n  val.refresh = msg.readInt32BE();\r\n  val.retry = msg.readInt32BE();\r\n  val.expiration = msg.readInt32BE();\r\n  val.minimum = msg.readInt32BE();\r\n  return PARSE_RESOURCE_DONE;\r\n}\r\n\r\n// http://tools.ietf.org/html/rfc3403#section-4.1\r\nfunction parseNaptr(val, msg) {\r\n  val.order = msg.readUInt16BE();\r\n  val.preference = msg.readUInt16BE();\r\n  var len = msg.readUInt8();\r\n  val.flags = msg.toString('ascii', len);\r\n  len = msg.readUInt8();\r\n  val.service = msg.toString('ascii', len);\r\n  len = msg.readUInt8();\r\n  val.regexp = msg.toString('ascii', len);\r\n  val.replacement = nameUnpack(msg);\r\n  return PARSE_RESOURCE_DONE;\r\n}\r\n\r\nfunction parseTlsa(val, msg, rdata) {\r\n  val.usage = msg.readUInt8();\r\n  val.selector = msg.readUInt8();\r\n  val.matchingtype = msg.readUInt8();\r\n  val.buff = msg.slice(rdata.len - 3).buffer; // 3 because of the 3 UInt8s above.\r\n  return PARSE_RESOURCE_DONE;\r\n}\r\n\r\n// https://tools.ietf.org/html/rfc6891#section-6.1.2\r\n// https://tools.ietf.org/html/rfc2671#section-4.4\r\n//       - [payload size selection](https://tools.ietf.org/html/rfc6891#section-6.2.5)\r\nfunction parseOpt(val, msg, rdata, packet) {\r\n  // assert first entry in additional\r\n  rdata.buf = msg.slice(rdata.len);\r\n\r\n  val.rcode = ((val.ttl & 0xFF000000) >> 20) + packet.header.rcode;\r\n  val.version = (val.ttl >> 16) & 0xFF;\r\n  val.do = (val.ttl >> 15) & 1;\r\n  val.z = val.ttl & 0x7F;\r\n  val.options = [];\r\n\r\n  packet.edns = val;\r\n  packet.edns_version = val.version; // TODO: return BADVERS for unsupported version! (Section 6.1.3)\r\n\r\n  // !! BEGIN DEPRECATION NOTICE !!\r\n  // THESE FIELDS MAY BE REMOVED IN THE FUTURE!\r\n  packet.edns_options = val.options;\r\n  packet.payload = val.class;\r\n  // !! END DEPRECATION NOTICE !!\r\n\r\n  while (!rdata.buf.eof()) {\r\n    val.options.push({\r\n      code: rdata.buf.readUInt16BE(),\r\n      data: rdata.buf.slice(rdata.buf.readUInt16BE()).buffer\r\n    });\r\n  }\r\n  return PARSE_RESOURCE_DONE;\r\n}\r\n\r\nvar\r\n  PARSE_HEADER          = 100000,\r\n  PARSE_QUESTION        = 100001,\r\n  PARSE_RESOURCE_RECORD = 100002,\r\n  PARSE_RR_UNPACK       = 100003,\r\n  PARSE_RESOURCE_DONE   = 100004,\r\n  PARSE_END             = 100005,\r\n  PARSE_A     = consts.NAME_TO_QTYPE.A,\r\n  PARSE_NS    = consts.NAME_TO_QTYPE.NS,\r\n  PARSE_CNAME = consts.NAME_TO_QTYPE.CNAME,\r\n  PARSE_SOA   = consts.NAME_TO_QTYPE.SOA,\r\n  PARSE_PTR   = consts.NAME_TO_QTYPE.PTR,\r\n  PARSE_MX    = consts.NAME_TO_QTYPE.MX,\r\n  PARSE_TXT   = consts.NAME_TO_QTYPE.TXT,\r\n  PARSE_AAAA  = consts.NAME_TO_QTYPE.AAAA,\r\n  PARSE_SRV   = consts.NAME_TO_QTYPE.SRV,\r\n  PARSE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\r\n  PARSE_OPT   = consts.NAME_TO_QTYPE.OPT,\r\n  PARSE_SPF   = consts.NAME_TO_QTYPE.SPF,\r\n  PARSE_TLSA  = consts.NAME_TO_QTYPE.TLSA;\r\n  \r\n\r\nPacket.parse = function(msg) {\r\n  var state,\r\n      pos,\r\n      val,\r\n      rdata,\r\n      section,\r\n      count;\r\n\r\n  var packet = new Packet();\r\n\r\n  pos = 0;\r\n  state = PARSE_HEADER;\r\n\r\n  msg = new BufferCursor(msg);\r\n\r\n  while (true) {\r\n    switch (state) {\r\n      case PARSE_HEADER:\r\n        state = parseHeader(msg, packet);\r\n        break;\r\n      case PARSE_QUESTION:\r\n        state = parseQuestion(msg, packet);\r\n        section = 'answer';\r\n        count = 0;\r\n        break;\r\n      case PARSE_RESOURCE_RECORD:\r\n        // console.log('PARSE_RESOURCE_RECORD: count = %d, %s.len = %d', count, section, packet[section].length);\r\n        if (count === packet[section].length) {\r\n          switch (section) {\r\n            case 'answer':\r\n              section = 'authority';\r\n              count = 0;\r\n              break;\r\n            case 'authority':\r\n              section = 'additional';\r\n              count = 0;\r\n              break;\r\n            case 'additional':\r\n              state = PARSE_END;\r\n              break;\r\n          }\r\n        } else {\r\n          state = PARSE_RR_UNPACK;\r\n        }\r\n        break;\r\n      case PARSE_RR_UNPACK:\r\n        val = {};\r\n        rdata = {};\r\n        state = parseRR(msg, val, rdata);\r\n        break;\r\n      case PARSE_RESOURCE_DONE:\r\n        packet[section][count++] = val;\r\n        state = PARSE_RESOURCE_RECORD;\r\n        break;\r\n      case PARSE_A:\r\n        state = parseA(val, msg);\r\n        break;\r\n      case PARSE_AAAA:\r\n        state = parseAAAA(val, msg);\r\n        break;\r\n      case PARSE_NS:\r\n      case PARSE_CNAME:\r\n      case PARSE_PTR:\r\n        state = parseCname(val, msg);\r\n        break;\r\n      case PARSE_SPF:\r\n      case PARSE_TXT:\r\n        state = parseTxt(val, msg, rdata);\r\n        break;\r\n      case PARSE_MX:\r\n        state = parseMx(val, msg);\r\n        break;\r\n      case PARSE_SRV:\r\n        state = parseSrv(val, msg);\r\n        break;\r\n      case PARSE_SOA:\r\n        state = parseSoa(val, msg);\r\n        break;\r\n      case PARSE_OPT:\r\n        state = parseOpt(val, msg, rdata, packet);\r\n        break;\r\n      case PARSE_NAPTR:\r\n        state = parseNaptr(val, msg);\r\n        break;\r\n      case PARSE_TLSA:\r\n        state = parseTlsa(val, msg, rdata);\r\n        break;\r\n      case PARSE_END:\r\n        return packet;\r\n      default:\r\n        //console.log(state, val);\r\n        val.data = msg.slice(rdata.len);\r\n        state = PARSE_RESOURCE_DONE;\r\n        break;\r\n    }\r\n  }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}