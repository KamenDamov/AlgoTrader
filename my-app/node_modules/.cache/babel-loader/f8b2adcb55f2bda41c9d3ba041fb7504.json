{"ast":null,"code":"'use strict';\n\n// eslint-disable-next-line\nvar Native = require('pg-native');\nvar TypeOverrides = require('../type-overrides');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar ConnectionParameters = require('../connection-parameters');\nvar NativeQuery = require('./query');\nvar Client = module.exports = function (config) {\n  EventEmitter.call(this);\n  config = config || {};\n  this._Promise = config.Promise || global.Promise;\n  this._types = new TypeOverrides(config.types);\n  this.native = new Native({\n    types: this._types\n  });\n  this._queryQueue = [];\n  this._ending = false;\n  this._connecting = false;\n  this._connected = false;\n  this._queryable = true;\n\n  // keep these on the object for legacy reasons\n  // for the time being. TODO: deprecate all this jazz\n  var cp = this.connectionParameters = new ConnectionParameters(config);\n  this.user = cp.user;\n\n  // \"hiding\" the password so it doesn't show up in stack traces\n  // or if the client is console.logged\n  Object.defineProperty(this, 'password', {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: cp.password\n  });\n  this.database = cp.database;\n  this.host = cp.host;\n  this.port = cp.port;\n\n  // a hash to hold named queries\n  this.namedQueries = {};\n};\nClient.Query = NativeQuery;\nutil.inherits(Client, EventEmitter);\nClient.prototype._errorAllQueries = function (err) {\n  var _this = this;\n  var enqueueError = function enqueueError(query) {\n    process.nextTick(function () {\n      query.native = _this.native;\n      query.handleError(err);\n    });\n  };\n  if (this._hasActiveQuery()) {\n    enqueueError(this._activeQuery);\n    this._activeQuery = null;\n  }\n  this._queryQueue.forEach(enqueueError);\n  this._queryQueue.length = 0;\n};\n\n// connect to the backend\n// pass an optional callback to be called once connected\n// or with an error if there was a connection error\nClient.prototype._connect = function (cb) {\n  var self = this;\n  if (this._connecting) {\n    process.nextTick(function () {\n      return cb(new Error('Client has already been connected. You cannot reuse a client.'));\n    });\n    return;\n  }\n  this._connecting = true;\n  this.connectionParameters.getLibpqConnectionString(function (err, conString) {\n    if (err) return cb(err);\n    self.native.connect(conString, function (err) {\n      if (err) {\n        self.native.end();\n        return cb(err);\n      }\n\n      // set internal states to connected\n      self._connected = true;\n\n      // handle connection errors from the native layer\n      self.native.on('error', function (err) {\n        self._queryable = false;\n        self._errorAllQueries(err);\n        self.emit('error', err);\n      });\n      self.native.on('notification', function (msg) {\n        self.emit('notification', {\n          channel: msg.relname,\n          payload: msg.extra\n        });\n      });\n\n      // signal we are connected now\n      self.emit('connect');\n      self._pulseQueryQueue(true);\n      cb();\n    });\n  });\n};\nClient.prototype.connect = function (callback) {\n  var _this2 = this;\n  if (callback) {\n    this._connect(callback);\n    return;\n  }\n  return new this._Promise(function (resolve, reject) {\n    _this2._connect(function (error) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve();\n      }\n    });\n  });\n};\n\n// send a query to the server\n// this method is highly overloaded to take\n// 1) string query, optional array of parameters, optional function callback\n// 2) object query with {\n//    string query\n//    optional array values,\n//    optional function callback instead of as a separate parameter\n//    optional string name to name & cache the query plan\n//    optional string rowMode = 'array' for an array of results\n//  }\nClient.prototype.query = function (config, values, callback) {\n  var _this3 = this;\n  var query;\n  var result;\n  var readTimeout;\n  var readTimeoutTimer;\n  var queryCallback;\n  if (config === null || config === undefined) {\n    throw new TypeError('Client was passed a null or undefined query');\n  } else if (typeof config.submit === 'function') {\n    readTimeout = config.query_timeout || this.connectionParameters.query_timeout;\n    result = query = config;\n    // accept query(new Query(...), (err, res) => { }) style\n    if (typeof values === 'function') {\n      config.callback = values;\n    }\n  } else {\n    readTimeout = this.connectionParameters.query_timeout;\n    query = new NativeQuery(config, values, callback);\n    if (!query.callback) {\n      var resolveOut, rejectOut;\n      result = new this._Promise(function (resolve, reject) {\n        resolveOut = resolve;\n        rejectOut = reject;\n      });\n      query.callback = function (err, res) {\n        return err ? rejectOut(err) : resolveOut(res);\n      };\n    }\n  }\n  if (readTimeout) {\n    queryCallback = query.callback;\n    readTimeoutTimer = setTimeout(function () {\n      var error = new Error('Query read timeout');\n      process.nextTick(function () {\n        query.handleError(error, _this3.connection);\n      });\n      queryCallback(error);\n\n      // we already returned an error,\n      // just do nothing if query completes\n      query.callback = function () {};\n\n      // Remove from queue\n      var index = _this3._queryQueue.indexOf(query);\n      if (index > -1) {\n        _this3._queryQueue.splice(index, 1);\n      }\n      _this3._pulseQueryQueue();\n    }, readTimeout);\n    query.callback = function (err, res) {\n      clearTimeout(readTimeoutTimer);\n      queryCallback(err, res);\n    };\n  }\n  if (!this._queryable) {\n    query.native = this.native;\n    process.nextTick(function () {\n      query.handleError(new Error('Client has encountered a connection error and is not queryable'));\n    });\n    return result;\n  }\n  if (this._ending) {\n    query.native = this.native;\n    process.nextTick(function () {\n      query.handleError(new Error('Client was closed and is not queryable'));\n    });\n    return result;\n  }\n  this._queryQueue.push(query);\n  this._pulseQueryQueue();\n  return result;\n};\n\n// disconnect from the backend server\nClient.prototype.end = function (cb) {\n  var self = this;\n  this._ending = true;\n  if (!this._connected) {\n    this.once('connect', this.end.bind(this, cb));\n  }\n  var result;\n  if (!cb) {\n    result = new this._Promise(function (resolve, reject) {\n      cb = function cb(err) {\n        return err ? reject(err) : resolve();\n      };\n    });\n  }\n  this.native.end(function () {\n    self._errorAllQueries(new Error('Connection terminated'));\n    process.nextTick(function () {\n      self.emit('end');\n      if (cb) cb();\n    });\n  });\n  return result;\n};\nClient.prototype._hasActiveQuery = function () {\n  return this._activeQuery && this._activeQuery.state !== 'error' && this._activeQuery.state !== 'end';\n};\nClient.prototype._pulseQueryQueue = function (initialConnection) {\n  if (!this._connected) {\n    return;\n  }\n  if (this._hasActiveQuery()) {\n    return;\n  }\n  var query = this._queryQueue.shift();\n  if (!query) {\n    if (!initialConnection) {\n      this.emit('drain');\n    }\n    return;\n  }\n  this._activeQuery = query;\n  query.submit(this);\n  var self = this;\n  query.once('_done', function () {\n    self._pulseQueryQueue();\n  });\n};\n\n// attempt to cancel an in-progress query\nClient.prototype.cancel = function (query) {\n  if (this._activeQuery === query) {\n    this.native.cancel(function () {});\n  } else if (this._queryQueue.indexOf(query) !== -1) {\n    this._queryQueue.splice(this._queryQueue.indexOf(query), 1);\n  }\n};\nClient.prototype.ref = function () {};\nClient.prototype.unref = function () {};\nClient.prototype.setTypeParser = function (oid, format, parseFn) {\n  return this._types.setTypeParser(oid, format, parseFn);\n};\nClient.prototype.getTypeParser = function (oid, format) {\n  return this._types.getTypeParser(oid, format);\n};","map":null,"metadata":{},"sourceType":"script"}