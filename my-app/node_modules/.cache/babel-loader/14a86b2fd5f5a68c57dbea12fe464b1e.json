{"ast":null,"code":"'use strict';\n\nvar extend = require('xtend/mutable');\nmodule.exports = PostgresInterval;\nfunction PostgresInterval(raw) {\n  if (!(this instanceof PostgresInterval)) {\n    return new PostgresInterval(raw);\n  }\n  extend(this, parse(raw));\n}\nvar properties = ['seconds', 'minutes', 'hours', 'days', 'months', 'years'];\nPostgresInterval.prototype.toPostgres = function () {\n  var filtered = properties.filter(this.hasOwnProperty, this);\n\n  // In addition to `properties`, we need to account for fractions of seconds.\n  if (this.milliseconds && filtered.indexOf('seconds') < 0) {\n    filtered.push('seconds');\n  }\n  if (filtered.length === 0) return '0';\n  return filtered.map(function (property) {\n    var value = this[property] || 0;\n\n    // Account for fractional part of seconds,\n    // remove trailing zeroes.\n    if (property === 'seconds' && this.milliseconds) {\n      value = (value + this.milliseconds / 1000).toFixed(6).replace(/\\.?0+$/, '');\n    }\n    return value + ' ' + property;\n  }, this).join(' ');\n};\nvar propertiesISOEquivalent = {\n  years: 'Y',\n  months: 'M',\n  days: 'D',\n  hours: 'H',\n  minutes: 'M',\n  seconds: 'S'\n};\nvar dateProperties = ['years', 'months', 'days'];\nvar timeProperties = ['hours', 'minutes', 'seconds'];\n// according to ISO 8601\nPostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function () {\n  var datePart = dateProperties.map(buildProperty, this).join('');\n  var timePart = timeProperties.map(buildProperty, this).join('');\n  return 'P' + datePart + 'T' + timePart;\n  function buildProperty(property) {\n    var value = this[property] || 0;\n\n    // Account for fractional part of seconds,\n    // remove trailing zeroes.\n    if (property === 'seconds' && this.milliseconds) {\n      value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, '');\n    }\n    return value + propertiesISOEquivalent[property];\n  }\n};\nvar NUMBER = '([+-]?\\\\d+)';\nvar YEAR = NUMBER + '\\\\s+years?';\nvar MONTH = NUMBER + '\\\\s+mons?';\nvar DAY = NUMBER + '\\\\s+days?';\nvar TIME = '([+-])?([\\\\d]*):(\\\\d\\\\d):(\\\\d\\\\d)\\\\.?(\\\\d{1,6})?';\nvar INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function (regexString) {\n  return '(' + regexString + ')?';\n}).join('\\\\s*'));\n\n// Positions of values in regex match\nvar positions = {\n  years: 2,\n  months: 4,\n  days: 6,\n  hours: 9,\n  minutes: 10,\n  seconds: 11,\n  milliseconds: 12\n};\n// We can use negative time\nvar negatives = ['hours', 'minutes', 'seconds', 'milliseconds'];\nfunction parseMilliseconds(fraction) {\n  // add omitted zeroes\n  var microseconds = fraction + '000000'.slice(fraction.length);\n  return parseInt(microseconds, 10) / 1000;\n}\nfunction parse(interval) {\n  if (!interval) return {};\n  var matches = INTERVAL.exec(interval);\n  var isNegative = matches[8] === '-';\n  return Object.keys(positions).reduce(function (parsed, property) {\n    var position = positions[property];\n    var value = matches[position];\n    // no empty string\n    if (!value) return parsed;\n    // milliseconds are actually microseconds (up to 6 digits)\n    // with omitted trailing zeroes.\n    value = property === 'milliseconds' ? parseMilliseconds(value) : parseInt(value, 10);\n    // no zeros\n    if (!value) return parsed;\n    if (isNegative && ~negatives.indexOf(property)) {\n      value *= -1;\n    }\n    parsed[property] = value;\n    return parsed;\n  }, {});\n}","map":null,"metadata":{},"sourceType":"script"}