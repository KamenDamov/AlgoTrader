{"ast":null,"code":"'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  const readableDestroyed = this._readableState && this._readableState.destroyed;\n  const writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, err => {\n    if (!cb && err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else {\n        process.nextTick(emitCloseNT, this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  const rState = stream._readableState;\n  const wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy,\n  undestroy,\n  errorOrDestroy\n};","map":{"version":3,"names":["destroy","err","cb","readableDestroyed","_readableState","destroyed","writableDestroyed","_writableState","process","nextTick","emitErrorNT","errorEmitted","_destroy","emitErrorAndCloseNT","emitCloseNT","self","emitClose","emit","undestroy","reading","ended","endEmitted","ending","finalCalled","prefinished","finished","errorOrDestroy","stream","rState","wState","autoDestroy","module","exports"],"sources":["C:/Users/Kamen/ML/AlgoTrader/node_modules/readable-stream/lib/internal/streams/destroy.js"],"sourcesContent":["'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  const readableDestroyed = this._readableState && this._readableState.destroyed;\n  const writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, err => {\n    if (!cb && err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else {\n        process.nextTick(emitCloseNT, this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const rState = stream._readableState;\n  const wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy,\n  undestroy,\n  errorOrDestroy\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}