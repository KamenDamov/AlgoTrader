{"ast":null,"code":"const timespan = require('./lib/timespan');\n\nconst PS_SUPPORTED = require('./lib/psSupported');\n\nconst validateAsymmetricKey = require('./lib/validateAsymmetricKey');\n\nconst jws = require('jws');\n\nconst {\n  includes,\n  isBoolean,\n  isInteger,\n  isNumber,\n  isPlainObject,\n  isString,\n  once\n} = require('lodash'); //const { KeyObject, createSecretKey, createPrivateKey } = require('crypto-browserify')\n\n\nconst SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];\n\nif (PS_SUPPORTED) {\n  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\n\nconst sign_options_schema = {\n  expiresIn: {\n    isValid: function (value) {\n      return isInteger(value) || isString(value) && value;\n    },\n    message: '\"expiresIn\" should be a number of seconds or string representing a timespan'\n  },\n  notBefore: {\n    isValid: function (value) {\n      return isInteger(value) || isString(value) && value;\n    },\n    message: '\"notBefore\" should be a number of seconds or string representing a timespan'\n  },\n  audience: {\n    isValid: function (value) {\n      return isString(value) || Array.isArray(value);\n    },\n    message: '\"audience\" must be a string or array'\n  },\n  algorithm: {\n    isValid: includes.bind(null, SUPPORTED_ALGS),\n    message: '\"algorithm\" must be a valid string enum value'\n  },\n  header: {\n    isValid: isPlainObject,\n    message: '\"header\" must be an object'\n  },\n  encoding: {\n    isValid: isString,\n    message: '\"encoding\" must be a string'\n  },\n  issuer: {\n    isValid: isString,\n    message: '\"issuer\" must be a string'\n  },\n  subject: {\n    isValid: isString,\n    message: '\"subject\" must be a string'\n  },\n  jwtid: {\n    isValid: isString,\n    message: '\"jwtid\" must be a string'\n  },\n  noTimestamp: {\n    isValid: isBoolean,\n    message: '\"noTimestamp\" must be a boolean'\n  },\n  keyid: {\n    isValid: isString,\n    message: '\"keyid\" must be a string'\n  },\n  mutatePayload: {\n    isValid: isBoolean,\n    message: '\"mutatePayload\" must be a boolean'\n  },\n  allowInsecureKeySizes: {\n    isValid: isBoolean,\n    message: '\"allowInsecureKeySizes\" must be a boolean'\n  },\n  allowInvalidAsymmetricKeyTypes: {\n    isValid: isBoolean,\n    message: '\"allowInvalidAsymmetricKeyTypes\" must be a boolean'\n  }\n};\nconst registered_claims_schema = {\n  iat: {\n    isValid: isNumber,\n    message: '\"iat\" should be a number of seconds'\n  },\n  exp: {\n    isValid: isNumber,\n    message: '\"exp\" should be a number of seconds'\n  },\n  nbf: {\n    isValid: isNumber,\n    message: '\"nbf\" should be a number of seconds'\n  }\n};\n\nfunction validate(schema, allowUnknown, object, parameterName) {\n  if (!isPlainObject(object)) {\n    throw new Error('Expected \"' + parameterName + '\" to be a plain object.');\n  }\n\n  Object.keys(object).forEach(function (key) {\n    const validator = schema[key];\n\n    if (!validator) {\n      if (!allowUnknown) {\n        throw new Error('\"' + key + '\" is not allowed in \"' + parameterName + '\"');\n      }\n\n      return;\n    }\n\n    if (!validator.isValid(object[key])) {\n      throw new Error(validator.message);\n    }\n  });\n}\n\nfunction validateOptions(options) {\n  return validate(sign_options_schema, false, options, 'options');\n}\n\nfunction validatePayload(payload) {\n  return validate(registered_claims_schema, true, payload, 'payload');\n}\n\nconst options_to_payload = {\n  'audience': 'aud',\n  'issuer': 'iss',\n  'subject': 'sub',\n  'jwtid': 'jti'\n};\nconst options_for_objects = ['expiresIn', 'notBefore', 'noTimestamp', 'audience', 'issuer', 'subject', 'jwtid'];\n\nmodule.exports = function (payload, secretOrPrivateKey, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else {\n    options = options || {};\n  }\n\n  const isObjectPayload = typeof payload === 'object' && !Buffer.isBuffer(payload);\n  const header = Object.assign({\n    alg: options.algorithm || 'HS256',\n    typ: isObjectPayload ? 'JWT' : undefined,\n    kid: options.keyid\n  }, options.header);\n\n  function failure(err) {\n    if (callback) {\n      return callback(err);\n    }\n\n    throw err;\n  }\n\n  if (!secretOrPrivateKey && options.algorithm !== 'none') {\n    return failure(new Error('secretOrPrivateKey must have a value'));\n  }\n\n  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {\n    try {\n      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);\n    } catch (_) {\n      try {\n        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === 'string' ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);\n      } catch (_) {\n        return failure(new Error('secretOrPrivateKey is not valid key material'));\n      }\n    }\n  }\n\n  if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') {\n    return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));\n  } else if (/^(?:RS|PS|ES)/.test(header.alg)) {\n    if (secretOrPrivateKey.type !== 'private') {\n      return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));\n    }\n\n    if (!options.allowInsecureKeySizes && !header.alg.startsWith('ES') && secretOrPrivateKey.asymmetricKeyDetails !== undefined && //KeyObject.asymmetricKeyDetails is supported in Node 15+\n    secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {\n      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));\n    }\n  }\n\n  if (typeof payload === 'undefined') {\n    return failure(new Error('payload is required'));\n  } else if (isObjectPayload) {\n    try {\n      validatePayload(payload);\n    } catch (error) {\n      return failure(error);\n    }\n\n    if (!options.mutatePayload) {\n      payload = Object.assign({}, payload);\n    }\n  } else {\n    const invalid_options = options_for_objects.filter(function (opt) {\n      return typeof options[opt] !== 'undefined';\n    });\n\n    if (invalid_options.length > 0) {\n      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + typeof payload + ' payload'));\n    }\n  }\n\n  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {\n    return failure(new Error('Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'));\n  }\n\n  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {\n    return failure(new Error('Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'));\n  }\n\n  try {\n    validateOptions(options);\n  } catch (error) {\n    return failure(error);\n  }\n\n  if (!options.allowInvalidAsymmetricKeyTypes) {\n    try {\n      validateAsymmetricKey(header.alg, secretOrPrivateKey);\n    } catch (error) {\n      return failure(error);\n    }\n  }\n\n  const timestamp = payload.iat || Math.floor(Date.now() / 1000);\n\n  if (options.noTimestamp) {\n    delete payload.iat;\n  } else if (isObjectPayload) {\n    payload.iat = timestamp;\n  }\n\n  if (typeof options.notBefore !== 'undefined') {\n    try {\n      payload.nbf = timespan(options.notBefore, timestamp);\n    } catch (err) {\n      return failure(err);\n    }\n\n    if (typeof payload.nbf === 'undefined') {\n      return failure(new Error('\"notBefore\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {\n    try {\n      payload.exp = timespan(options.expiresIn, timestamp);\n    } catch (err) {\n      return failure(err);\n    }\n\n    if (typeof payload.exp === 'undefined') {\n      return failure(new Error('\"expiresIn\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  Object.keys(options_to_payload).forEach(function (key) {\n    const claim = options_to_payload[key];\n\n    if (typeof options[key] !== 'undefined') {\n      if (typeof payload[claim] !== 'undefined') {\n        return failure(new Error('Bad \"options.' + key + '\" option. The payload already has an \"' + claim + '\" property.'));\n      }\n\n      payload[claim] = options[key];\n    }\n  });\n  const encoding = options.encoding || 'utf8';\n\n  if (typeof callback === 'function') {\n    callback = callback && once(callback);\n    jws.createSign({\n      header: header,\n      privateKey: secretOrPrivateKey,\n      payload: payload,\n      encoding: encoding\n    }).once('error', callback).once('done', function (signature) {\n      // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n      if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n        return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));\n      }\n\n      callback(null, signature);\n    });\n  } else {\n    let signature = jws.sign({\n      header: header,\n      payload: payload,\n      secret: secretOrPrivateKey,\n      encoding: encoding\n    }); // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n\n    if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);\n    }\n\n    return signature;\n  }\n};","map":{"version":3,"names":["timespan","require","PS_SUPPORTED","validateAsymmetricKey","jws","includes","isBoolean","isInteger","isNumber","isPlainObject","isString","once","SUPPORTED_ALGS","splice","sign_options_schema","expiresIn","isValid","value","message","notBefore","audience","Array","isArray","algorithm","bind","header","encoding","issuer","subject","jwtid","noTimestamp","keyid","mutatePayload","allowInsecureKeySizes","allowInvalidAsymmetricKeyTypes","registered_claims_schema","iat","exp","nbf","validate","schema","allowUnknown","object","parameterName","Error","Object","keys","forEach","key","validator","validateOptions","options","validatePayload","payload","options_to_payload","options_for_objects","module","exports","secretOrPrivateKey","callback","isObjectPayload","Buffer","isBuffer","assign","alg","typ","undefined","kid","failure","err","KeyObject","createPrivateKey","_","createSecretKey","from","startsWith","type","test","asymmetricKeyDetails","modulusLength","error","invalid_options","filter","opt","length","join","timestamp","Math","floor","Date","now","claim","createSign","privateKey","signature","sign","secret"],"sources":["C:/Users/Kamen/ML/AlgoTrader/my-app/node_modules/jsonwebtoken/sign.js"],"sourcesContent":["const timespan = require('./lib/timespan');\nconst PS_SUPPORTED = require('./lib/psSupported');\nconst validateAsymmetricKey = require('./lib/validateAsymmetricKey');\nconst jws = require('jws');\nconst {includes, isBoolean, isInteger, isNumber, isPlainObject, isString, once} = require('lodash')\n//const { KeyObject, createSecretKey, createPrivateKey } = require('crypto-browserify')\n\nconst SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];\nif (PS_SUPPORTED) {\n  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\n\nconst sign_options_schema = {\n  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"expiresIn\" should be a number of seconds or string representing a timespan' },\n  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"notBefore\" should be a number of seconds or string representing a timespan' },\n  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '\"audience\" must be a string or array' },\n  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '\"algorithm\" must be a valid string enum value' },\n  header: { isValid: isPlainObject, message: '\"header\" must be an object' },\n  encoding: { isValid: isString, message: '\"encoding\" must be a string' },\n  issuer: { isValid: isString, message: '\"issuer\" must be a string' },\n  subject: { isValid: isString, message: '\"subject\" must be a string' },\n  jwtid: { isValid: isString, message: '\"jwtid\" must be a string' },\n  noTimestamp: { isValid: isBoolean, message: '\"noTimestamp\" must be a boolean' },\n  keyid: { isValid: isString, message: '\"keyid\" must be a string' },\n  mutatePayload: { isValid: isBoolean, message: '\"mutatePayload\" must be a boolean' },\n  allowInsecureKeySizes: { isValid: isBoolean, message: '\"allowInsecureKeySizes\" must be a boolean'},\n  allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '\"allowInvalidAsymmetricKeyTypes\" must be a boolean'}\n};\n\nconst registered_claims_schema = {\n  iat: { isValid: isNumber, message: '\"iat\" should be a number of seconds' },\n  exp: { isValid: isNumber, message: '\"exp\" should be a number of seconds' },\n  nbf: { isValid: isNumber, message: '\"nbf\" should be a number of seconds' }\n};\n\nfunction validate(schema, allowUnknown, object, parameterName) {\n  if (!isPlainObject(object)) {\n    throw new Error('Expected \"' + parameterName + '\" to be a plain object.');\n  }\n  Object.keys(object)\n    .forEach(function(key) {\n      const validator = schema[key];\n      if (!validator) {\n        if (!allowUnknown) {\n          throw new Error('\"' + key + '\" is not allowed in \"' + parameterName + '\"');\n        }\n        return;\n      }\n      if (!validator.isValid(object[key])) {\n        throw new Error(validator.message);\n      }\n    });\n}\n\nfunction validateOptions(options) {\n  return validate(sign_options_schema, false, options, 'options');\n}\n\nfunction validatePayload(payload) {\n  return validate(registered_claims_schema, true, payload, 'payload');\n}\n\nconst options_to_payload = {\n  'audience': 'aud',\n  'issuer': 'iss',\n  'subject': 'sub',\n  'jwtid': 'jti'\n};\n\nconst options_for_objects = [\n  'expiresIn',\n  'notBefore',\n  'noTimestamp',\n  'audience',\n  'issuer',\n  'subject',\n  'jwtid',\n];\n\nmodule.exports = function (payload, secretOrPrivateKey, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else {\n    options = options || {};\n  }\n\n  const isObjectPayload = typeof payload === 'object' &&\n                        !Buffer.isBuffer(payload);\n\n  const header = Object.assign({\n    alg: options.algorithm || 'HS256',\n    typ: isObjectPayload ? 'JWT' : undefined,\n    kid: options.keyid\n  }, options.header);\n\n  function failure(err) {\n    if (callback) {\n      return callback(err);\n    }\n    throw err;\n  }\n\n  if (!secretOrPrivateKey && options.algorithm !== 'none') {\n    return failure(new Error('secretOrPrivateKey must have a value'));\n  }\n\n  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {\n    try {\n      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey)\n    } catch (_) {\n      try {\n        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === 'string' ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey)\n      } catch (_) {\n        return failure(new Error('secretOrPrivateKey is not valid key material'));\n      }\n    }\n  }\n\n  if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') {\n    return failure(new Error((`secretOrPrivateKey must be a symmetric key when using ${header.alg}`)))\n  } else if (/^(?:RS|PS|ES)/.test(header.alg)) {\n    if (secretOrPrivateKey.type !== 'private') {\n      return failure(new Error((`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`)))\n    }\n    if (!options.allowInsecureKeySizes &&\n      !header.alg.startsWith('ES') &&\n      secretOrPrivateKey.asymmetricKeyDetails !== undefined && //KeyObject.asymmetricKeyDetails is supported in Node 15+\n      secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {\n      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));\n    }\n  }\n\n  if (typeof payload === 'undefined') {\n    return failure(new Error('payload is required'));\n  } else if (isObjectPayload) {\n    try {\n      validatePayload(payload);\n    }\n    catch (error) {\n      return failure(error);\n    }\n    if (!options.mutatePayload) {\n      payload = Object.assign({},payload);\n    }\n  } else {\n    const invalid_options = options_for_objects.filter(function (opt) {\n      return typeof options[opt] !== 'undefined';\n    });\n\n    if (invalid_options.length > 0) {\n      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));\n    }\n  }\n\n  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {\n    return failure(new Error('Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'));\n  }\n\n  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {\n    return failure(new Error('Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'));\n  }\n\n  try {\n    validateOptions(options);\n  }\n  catch (error) {\n    return failure(error);\n  }\n\n  if (!options.allowInvalidAsymmetricKeyTypes) {\n    try {\n      validateAsymmetricKey(header.alg, secretOrPrivateKey);\n    } catch (error) {\n      return failure(error);\n    }\n  }\n\n  const timestamp = payload.iat || Math.floor(Date.now() / 1000);\n\n  if (options.noTimestamp) {\n    delete payload.iat;\n  } else if (isObjectPayload) {\n    payload.iat = timestamp;\n  }\n\n  if (typeof options.notBefore !== 'undefined') {\n    try {\n      payload.nbf = timespan(options.notBefore, timestamp);\n    }\n    catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.nbf === 'undefined') {\n      return failure(new Error('\"notBefore\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {\n    try {\n      payload.exp = timespan(options.expiresIn, timestamp);\n    }\n    catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.exp === 'undefined') {\n      return failure(new Error('\"expiresIn\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  Object.keys(options_to_payload).forEach(function (key) {\n    const claim = options_to_payload[key];\n    if (typeof options[key] !== 'undefined') {\n      if (typeof payload[claim] !== 'undefined') {\n        return failure(new Error('Bad \"options.' + key + '\" option. The payload already has an \"' + claim + '\" property.'));\n      }\n      payload[claim] = options[key];\n    }\n  });\n\n  const encoding = options.encoding || 'utf8';\n\n  if (typeof callback === 'function') {\n    callback = callback && once(callback);\n\n    jws.createSign({\n      header: header,\n      privateKey: secretOrPrivateKey,\n      payload: payload,\n      encoding: encoding\n    }).once('error', callback)\n      .once('done', function (signature) {\n        // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n        if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`))\n        }\n        callback(null, signature);\n      });\n  } else {\n    let signature = jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});\n    // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n    if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`)\n    }\n    return signature\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}