{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst os = require('os');\n\nconst tar = require('tar');\n\nconst path = require('path');\n\nconst util = require('util');\n\nconst stream = require('stream');\n\nconst crypto = require('crypto');\n\nconst log = require('npmlog');\n\nconst semver = require('semver');\n\nconst fetch = require('make-fetch-happen');\n\nconst processRelease = require('./process-release');\n\nconst win = process.platform === 'win32';\nconst streamPipeline = util.promisify(stream.pipeline);\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install(fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release); // Determine which node dev files version we are installing\n\n  log.verbose('install', 'input version string %j', release.version);\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version);\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version);\n  } // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n\n\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version);\n\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead');\n    }\n\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n    return;\n  } // flatten version into String\n\n\n  log.verbose('install', 'installing version: %s', release.versionDir); // the directory where the dev files will be installed\n\n  const devDir = path.resolve(gyp.devDir, release.versionDir); // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n\n    try {\n      await fs.promises.stat(devDir);\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version);\n\n        try {\n          return await go();\n        } catch (err) {\n          return rollback(err);\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err);\n      }\n\n      throw err;\n    }\n\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n    const installVersionFile = path.resolve(devDir, 'installVersion');\n    let installVersion = 0;\n\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii');\n      installVersion = parseInt(ver, 10) || 0;\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n\n    log.verbose('got \"installVersion\"', installVersion);\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling');\n\n      try {\n        return await go();\n      } catch (err) {\n        return rollback(err);\n      }\n    }\n\n    log.verbose('install', 'version is good');\n  } else {\n    try {\n      return await go();\n    } catch (err) {\n      return rollback(err);\n    }\n  }\n\n  async function go() {\n    log.verbose('ensuring nodedir is created', devDir); // first create the dir for the node dev files\n\n    try {\n      const created = await fs.promises.mkdir(devDir, {\n        recursive: true\n      });\n\n      if (created) {\n        log.verbose('created nodedir', created);\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err);\n      }\n\n      throw err;\n    } // now download the node tarball\n\n\n    const tarPath = gyp.opts.tarball;\n    let extractCount = 0;\n    const contentShasums = {};\n    const expectShasums = {}; // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n\n    function isValid(path) {\n      const isValid = valid(path);\n\n      if (isValid) {\n        log.verbose('extracted file from tarball', path);\n        extractCount++;\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path);\n      }\n\n      return isValid;\n    } // download the tarball and extract!\n\n\n    if (tarPath) {\n      await tar.extract({\n        file: tarPath,\n        strip: 1,\n        filter: isValid,\n        cwd: devDir\n      });\n    } else {\n      try {\n        const res = await download(gyp, release.tarballUrl);\n\n        if (res.status !== 200) {\n          throw new Error(`${res.status} response downloading ${release.tarballUrl}`);\n        }\n\n        await streamPipeline(res.body, // content checksum\n        new ShaSum((_, checksum) => {\n          const filename = path.basename(release.tarballUrl).trim();\n          contentShasums[filename] = checksum;\n          log.verbose('content checksum', filename, checksum);\n        }), tar.extract({\n          strip: 1,\n          cwd: devDir,\n          filter: isValid\n        }));\n      } catch (err) {\n        // something went wrong downloading the tarball?\n        if (err.code === 'ENOTFOUND') {\n          throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.');\n        }\n\n        throw err;\n      }\n    } // invoked after the tarball has finished being extracted\n\n\n    if (extractCount === 0) {\n      throw new Error('There was a fatal problem while downloading/extracting the tarball');\n    }\n\n    log.verbose('tarball', 'done parsing tarball');\n    const installVersionPath = path.resolve(devDir, 'installVersion');\n    await Promise.all([// need to download node.lib\n    ...(win ? downloadNodeLib() : []), // write the \"installVersion\" file\n    fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'), // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n    ...(!tarPath || win ? [downloadShasums()] : [])]);\n    log.verbose('download contents checksum', JSON.stringify(contentShasums)); // check content shasums\n\n    for (const k in contentShasums) {\n      log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n\n      if (contentShasums[k] !== expectShasums[k]) {\n        throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]);\n      }\n    }\n\n    async function downloadShasums() {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n      log.verbose('checksum url', release.shasumsUrl);\n      const res = await download(gyp, release.shasumsUrl);\n\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`);\n      }\n\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/);\n\n        if (items.length !== 2) {\n          return;\n        } // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n\n\n        const name = items[1].replace(/^\\.\\//, '');\n        expectShasums[name] = items[0];\n      }\n\n      log.verbose('checksum data', JSON.stringify(expectShasums));\n    }\n\n    function downloadNodeLib() {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n      const archs = ['ia32', 'x64', 'arm64'];\n      return archs.map(async arch => {\n        const dir = path.resolve(devDir, arch);\n        const targetLibPath = path.resolve(dir, release.name + '.lib');\n        const {\n          libUrl,\n          libPath\n        } = release[arch];\n        const name = `${arch} ${release.name}.lib`;\n        log.verbose(name, 'dir', dir);\n        log.verbose(name, 'url', libUrl);\n        await fs.promises.mkdir(dir, {\n          recursive: true\n        });\n        log.verbose('streaming', name, 'to:', targetLibPath);\n        const res = await download(gyp, libUrl);\n\n        if (res.status === 403 || res.status === 404) {\n          if (arch === 'arm64') {\n            // Arm64 is a newer platform on Windows and not all node distributions provide it.\n            log.verbose(`${name} was not found in ${libUrl}`);\n          } else {\n            log.warn(`${name} was not found in ${libUrl}`);\n          }\n\n          return;\n        } else if (res.status !== 200) {\n          throw new Error(`${res.status} status code downloading ${name}`);\n        }\n\n        return streamPipeline(res.body, new ShaSum((_, checksum) => {\n          contentShasums[libPath] = checksum;\n          log.verbose('content checksum', libPath, checksum);\n        }), fs.createWriteStream(targetLibPath));\n      });\n    } // downloadNodeLib()\n\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n\n  function valid(file) {\n    // header files\n    const extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n\n  async function rollback(err) {\n    log.warn('install', 'got an error, rolling back install'); // roll-back the install if anything went wrong\n\n    await util.promisify(gyp.commands.remove)([release.versionDir]);\n    throw err;\n  }\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n\n  async function eaccesFallback(err) {\n    const noretry = '--node_gyp_internal_noretry';\n\n    if (argv.indexOf(noretry) !== -1) {\n      throw err;\n    }\n\n    const tmpdir = os.tmpdir();\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n    let userString = '';\n\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`;\n    } catch (e) {}\n\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n      gyp.todo.push({\n        name: 'remove',\n        args: argv\n      });\n    }\n\n    return util.promisify(gyp.commands.install)([noretry].concat(argv));\n  }\n}\n\nclass ShaSum extends stream.Transform {\n  constructor(callback) {\n    super();\n    this._callback = callback;\n    this._digester = crypto.createHash('sha256');\n  }\n\n  _transform(chunk, _, callback) {\n    this._digester.update(chunk);\n\n    callback(null, chunk);\n  }\n\n  _flush(callback) {\n    this._callback(null, this._digester.digest('hex'));\n\n    callback();\n  }\n\n}\n\nasync function download(gyp, url) {\n  log.http('GET', url);\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  };\n  const cafile = gyp.opts.cafile;\n\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile);\n  }\n\n  const res = await fetch(url, requestOpts);\n  log.http(res.status, res.url);\n  return res;\n}\n\nasync function readCAFile(filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8');\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n  return ca.match(re);\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback);\n};\n\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"names":["fs","require","os","tar","path","util","stream","crypto","log","semver","fetch","processRelease","win","process","platform","streamPipeline","promisify","pipeline","install","gyp","argv","release","version","verbose","Error","lt","prerelease","opts","nodedir","versionDir","devDir","resolve","ensure","promises","stat","err","code","go","rollback","eaccesFallback","installVersionFile","installVersion","ver","readFile","parseInt","package","created","mkdir","recursive","tarPath","tarball","extractCount","contentShasums","expectShasums","isValid","valid","silly","extract","file","strip","filter","cwd","res","download","tarballUrl","status","body","ShaSum","_","checksum","filename","basename","trim","installVersionPath","Promise","all","downloadNodeLib","writeFile","downloadShasums","JSON","stringify","k","shasumsUrl","line","text","split","items","length","name","replace","archs","map","arch","dir","targetLibPath","libUrl","libPath","warn","createWriteStream","extname","commands","remove","noretry","indexOf","tmpdir","userString","userInfo","username","e","todo","push","args","concat","Transform","constructor","callback","_callback","_digester","createHash","_transform","chunk","update","_flush","digest","url","http","requestOpts","headers","Connection","proxy","noProxy","noproxy","cafile","ca","readCAFile","re","match","module","exports","then","bind","undefined","test","usage"],"sources":["C:/Users/Kamen/ML/AlgoTrader/node_modules/node-gyp/lib/install.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst tar = require('tar')\nconst path = require('path')\nconst util = require('util')\nconst stream = require('stream')\nconst crypto = require('crypto')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst fetch = require('make-fetch-happen')\nconst processRelease = require('./process-release')\nconst win = process.platform === 'win32'\nconst streamPipeline = util.promisify(stream.pipeline)\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install (fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release)\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version)\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version)\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead')\n    }\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  const devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    try {\n      await fs.promises.stat(devDir)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version)\n        try {\n          return await go()\n        } catch (err) {\n          return rollback(err)\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n      throw err\n    }\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n    const installVersionFile = path.resolve(devDir, 'installVersion')\n    let installVersion = 0\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii')\n      installVersion = parseInt(ver, 10) || 0\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n    log.verbose('got \"installVersion\"', installVersion)\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling')\n      try {\n        return await go()\n      } catch (err) {\n        return rollback(err)\n      }\n    }\n    log.verbose('install', 'version is good')\n  } else {\n    try {\n      return await go()\n    } catch (err) {\n      return rollback(err)\n    }\n  }\n\n  async function go () {\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    try {\n      const created = await fs.promises.mkdir(devDir, { recursive: true })\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n\n      throw err\n    }\n\n    // now download the node tarball\n    const tarPath = gyp.opts.tarball\n    let extractCount = 0\n    const contentShasums = {}\n    const expectShasums = {}\n\n    // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n    function isValid (path) {\n      const isValid = valid(path)\n      if (isValid) {\n        log.verbose('extracted file from tarball', path)\n        extractCount++\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path)\n      }\n      return isValid\n    }\n\n    // download the tarball and extract!\n\n    if (tarPath) {\n      await tar.extract({\n        file: tarPath,\n        strip: 1,\n        filter: isValid,\n        cwd: devDir\n      })\n    } else {\n      try {\n        const res = await download(gyp, release.tarballUrl)\n\n        if (res.status !== 200) {\n          throw new Error(`${res.status} response downloading ${release.tarballUrl}`)\n        }\n\n        await streamPipeline(\n          res.body,\n          // content checksum\n          new ShaSum((_, checksum) => {\n            const filename = path.basename(release.tarballUrl).trim()\n            contentShasums[filename] = checksum\n            log.verbose('content checksum', filename, checksum)\n          }),\n          tar.extract({\n            strip: 1,\n            cwd: devDir,\n            filter: isValid\n          })\n        )\n      } catch (err) {\n        // something went wrong downloading the tarball?\n        if (err.code === 'ENOTFOUND') {\n          throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.')\n        }\n        throw err\n      }\n    }\n\n    // invoked after the tarball has finished being extracted\n    if (extractCount === 0) {\n      throw new Error('There was a fatal problem while downloading/extracting the tarball')\n    }\n\n    log.verbose('tarball', 'done parsing tarball')\n\n    const installVersionPath = path.resolve(devDir, 'installVersion')\n    await Promise.all([\n      // need to download node.lib\n      ...(win ? downloadNodeLib() : []),\n      // write the \"installVersion\" file\n      fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n      // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n      ...(!tarPath || win ? [downloadShasums()] : [])\n    ])\n\n    log.verbose('download contents checksum', JSON.stringify(contentShasums))\n    // check content shasums\n    for (const k in contentShasums) {\n      log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n      if (contentShasums[k] !== expectShasums[k]) {\n        throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k])\n      }\n    }\n\n    async function downloadShasums () {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n      log.verbose('checksum url', release.shasumsUrl)\n\n      const res = await download(gyp, release.shasumsUrl)\n\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`)\n      }\n\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/)\n        if (items.length !== 2) {\n          return\n        }\n\n        // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n        const name = items[1].replace(/^\\.\\//, '')\n        expectShasums[name] = items[0]\n      }\n\n      log.verbose('checksum data', JSON.stringify(expectShasums))\n    }\n\n    function downloadNodeLib () {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n      const archs = ['ia32', 'x64', 'arm64']\n      return archs.map(async (arch) => {\n        const dir = path.resolve(devDir, arch)\n        const targetLibPath = path.resolve(dir, release.name + '.lib')\n        const { libUrl, libPath } = release[arch]\n        const name = `${arch} ${release.name}.lib`\n        log.verbose(name, 'dir', dir)\n        log.verbose(name, 'url', libUrl)\n\n        await fs.promises.mkdir(dir, { recursive: true })\n        log.verbose('streaming', name, 'to:', targetLibPath)\n\n        const res = await download(gyp, libUrl)\n\n        if (res.status === 403 || res.status === 404) {\n          if (arch === 'arm64') {\n            // Arm64 is a newer platform on Windows and not all node distributions provide it.\n            log.verbose(`${name} was not found in ${libUrl}`)\n          } else {\n            log.warn(`${name} was not found in ${libUrl}`)\n          }\n          return\n        } else if (res.status !== 200) {\n          throw new Error(`${res.status} status code downloading ${name}`)\n        }\n\n        return streamPipeline(\n          res.body,\n          new ShaSum((_, checksum) => {\n            contentShasums[libPath] = checksum\n            log.verbose('content checksum', libPath, checksum)\n          }),\n          fs.createWriteStream(targetLibPath)\n        )\n      })\n    } // downloadNodeLib()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    const extname = path.extname(file)\n    return extname === '.h' || extname === '.gypi'\n  }\n\n  async function rollback (err) {\n    log.warn('install', 'got an error, rolling back install')\n    // roll-back the install if anything went wrong\n    await util.promisify(gyp.commands.remove)([release.versionDir])\n    throw err\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  async function eaccesFallback (err) {\n    const noretry = '--node_gyp_internal_noretry'\n    if (argv.indexOf(noretry) !== -1) {\n      throw err\n    }\n    const tmpdir = os.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    let userString = ''\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    return util.promisify(gyp.commands.install)([noretry].concat(argv))\n  }\n}\n\nclass ShaSum extends stream.Transform {\n  constructor (callback) {\n    super()\n    this._callback = callback\n    this._digester = crypto.createHash('sha256')\n  }\n\n  _transform (chunk, _, callback) {\n    this._digester.update(chunk)\n    callback(null, chunk)\n  }\n\n  _flush (callback) {\n    this._callback(null, this._digester.digest('hex'))\n    callback()\n  }\n}\n\nasync function download (gyp, url) {\n  log.http('GET', url)\n\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  }\n\n  const cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile)\n  }\n\n  const res = await fetch(url, requestOpts)\n  log.http(res.status, res.url)\n\n  return res\n}\n\nasync function readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8')\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback)\n}\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n}\nmodule.exports.usage = 'Install node development files for the specified node version.'\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}