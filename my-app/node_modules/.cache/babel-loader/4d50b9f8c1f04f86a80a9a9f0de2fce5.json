{"ast":null,"code":"'use strict';\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nconst validateName = name => {\n  name = `${name}`;\n  if (invalidTokenRegex.test(name) || name === '') throw new TypeError(`${name} is not a legal HTTP header name`);\n};\n\nconst validateValue = value => {\n  value = `${value}`;\n  if (invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);\n};\n\nconst find = (map, name) => {\n  name = name.toLowerCase();\n\n  for (const key in map) {\n    if (key.toLowerCase() === name) return key;\n  }\n\n  return undefined;\n};\n\nconst MAP = Symbol('map');\n\nclass Headers {\n  constructor() {\n    let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    this[MAP] = Object.create(null);\n\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw();\n      const headerNames = Object.keys(rawHeaders);\n\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value);\n        }\n      }\n\n      return;\n    } // no-op\n\n\n    if (init === undefined || init === null) return;\n\n    if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n\n      if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') throw new TypeError('Header pairs must be iterable'); // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n\n        const pairs = [];\n\n        for (const pair of init) {\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') throw new TypeError('Each header pair must be iterable');\n          const arrPair = Array.from(pair);\n          if (arrPair.length !== 2) throw new TypeError('Each header pair must be a name/value tuple');\n          pairs.push(arrPair);\n        }\n\n        for (const pair of pairs) {\n          this.append(pair[0], pair[1]);\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          this.append(key, init[key]);\n        }\n      }\n    } else throw new TypeError('Provided initializer must be an object');\n  }\n\n  get(name) {\n    name = `${name}`;\n    validateName(name);\n    const key = find(this[MAP], name);\n    if (key === undefined) return null;\n    return this[MAP][key].join(', ');\n  }\n\n  forEach(callback) {\n    let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let pairs = getHeaders(this);\n\n    for (let i = 0; i < pairs.length; i++) {\n      const [name, value] = pairs[i];\n      callback.call(thisArg, value, name, this); // refresh in case the callback added more headers\n\n      pairs = getHeaders(this);\n    }\n  }\n\n  set(name, value) {\n    name = `${name}`;\n    value = `${value}`;\n    validateName(name);\n    validateValue(value);\n    const key = find(this[MAP], name);\n    this[MAP][key !== undefined ? key : name] = [value];\n  }\n\n  append(name, value) {\n    name = `${name}`;\n    value = `${value}`;\n    validateName(name);\n    validateValue(value);\n    const key = find(this[MAP], name);\n    if (key !== undefined) this[MAP][key].push(value);else this[MAP][name] = [value];\n  }\n\n  has(name) {\n    name = `${name}`;\n    validateName(name);\n    return find(this[MAP], name) !== undefined;\n  }\n\n  delete(name) {\n    name = `${name}`;\n    validateName(name);\n    const key = find(this[MAP], name);\n    if (key !== undefined) delete this[MAP][key];\n  }\n\n  raw() {\n    return this[MAP];\n  }\n\n  keys() {\n    return new HeadersIterator(this, 'key');\n  }\n\n  values() {\n    return new HeadersIterator(this, 'value');\n  }\n\n  [Symbol.iterator]() {\n    return new HeadersIterator(this, 'key+value');\n  }\n\n  entries() {\n    return new HeadersIterator(this, 'key+value');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Headers';\n  }\n\n  static exportNodeCompatibleHeaders(headers) {\n    const obj = Object.assign(Object.create(null), headers[MAP]); // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n\n    const hostHeaderKey = find(headers[MAP], 'Host');\n    if (hostHeaderKey !== undefined) obj[hostHeaderKey] = obj[hostHeaderKey][0];\n    return obj;\n  }\n\n  static createHeadersLenient(obj) {\n    const headers = new Headers();\n\n    for (const name of Object.keys(obj)) {\n      if (invalidTokenRegex.test(name)) continue;\n\n      if (Array.isArray(obj[name])) {\n        for (const val of obj[name]) {\n          if (invalidHeaderCharRegex.test(val)) continue;\n          if (headers[MAP][name] === undefined) headers[MAP][name] = [val];else headers[MAP][name].push(val);\n        }\n      } else if (!invalidHeaderCharRegex.test(obj[name])) headers[MAP][name] = [obj[name]];\n    }\n\n    return headers;\n  }\n\n}\n\nObject.defineProperties(Headers.prototype, {\n  get: {\n    enumerable: true\n  },\n  forEach: {\n    enumerable: true\n  },\n  set: {\n    enumerable: true\n  },\n  append: {\n    enumerable: true\n  },\n  has: {\n    enumerable: true\n  },\n  delete: {\n    enumerable: true\n  },\n  keys: {\n    enumerable: true\n  },\n  values: {\n    enumerable: true\n  },\n  entries: {\n    enumerable: true\n  }\n});\n\nconst getHeaders = function (headers) {\n  let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n  return Object.keys(headers[MAP]).sort().map(kind === 'key' ? k => k.toLowerCase() : kind === 'value' ? k => headers[MAP][k].join(', ') : k => [k.toLowerCase(), headers[MAP][k].join(', ')]);\n};\n\nconst INTERNAL = Symbol('internal');\n\nclass HeadersIterator {\n  constructor(target, kind) {\n    this[INTERNAL] = {\n      target,\n      kind,\n      index: 0\n    };\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'HeadersIterator';\n  }\n\n  next() {\n    /* istanbul ignore if: should be impossible */\n    if (!this || Object.getPrototypeOf(this) !== HeadersIterator.prototype) throw new TypeError('Value of `this` is not a HeadersIterator');\n    const {\n      target,\n      kind,\n      index\n    } = this[INTERNAL];\n    const values = getHeaders(target, kind);\n    const len = values.length;\n\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    this[INTERNAL].index++;\n    return {\n      value: values[index],\n      done: false\n    };\n  }\n\n} // manually extend because 'extends' requires a ctor\n\n\nObject.setPrototypeOf(HeadersIterator.prototype, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nmodule.exports = Headers;","map":{"version":3,"names":["invalidTokenRegex","invalidHeaderCharRegex","validateName","name","test","TypeError","validateValue","value","find","map","toLowerCase","key","undefined","MAP","Symbol","Headers","constructor","init","Object","create","rawHeaders","raw","headerNames","keys","headerName","append","method","iterator","pairs","pair","arrPair","Array","from","length","push","get","join","forEach","callback","thisArg","getHeaders","i","call","set","has","delete","HeadersIterator","values","entries","toStringTag","exportNodeCompatibleHeaders","headers","obj","assign","hostHeaderKey","createHeadersLenient","isArray","val","defineProperties","prototype","enumerable","kind","sort","k","INTERNAL","target","index","next","getPrototypeOf","len","done","setPrototypeOf","module","exports"],"sources":["C:/Users/Kamen/ML/AlgoTrader/node_modules/minipass-fetch/lib/headers.js"],"sourcesContent":["'use strict'\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\nconst validateName = name => {\n  name = `${name}`\n  if (invalidTokenRegex.test(name) || name === '')\n    throw new TypeError(`${name} is not a legal HTTP header name`)\n}\n\nconst validateValue = value => {\n  value = `${value}`\n  if (invalidHeaderCharRegex.test(value))\n    throw new TypeError(`${value} is not a legal HTTP header value`)\n}\n\nconst find = (map, name) => {\n  name = name.toLowerCase()\n  for (const key in map) {\n    if (key.toLowerCase() === name)\n      return key\n  }\n  return undefined\n}\n\nconst MAP = Symbol('map')\nclass Headers {\n  constructor (init = undefined) {\n    this[MAP] = Object.create(null)\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw()\n      const headerNames = Object.keys(rawHeaders)\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value)\n        }\n      }\n      return\n    }\n\n    // no-op\n    if (init === undefined || init === null)\n      return\n\n    if (typeof init === 'object') {\n      const method = init[Symbol.iterator]\n      if (method !== null && method !== undefined) {\n        if (typeof method !== 'function')\n          throw new TypeError('Header pairs must be iterable')\n\n        // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = []\n        for (const pair of init) {\n          if (typeof pair !== 'object' ||\n              typeof pair[Symbol.iterator] !== 'function')\n            throw new TypeError('Each header pair must be iterable')\n          const arrPair = Array.from(pair)\n          if (arrPair.length !== 2)\n            throw new TypeError('Each header pair must be a name/value tuple')\n          pairs.push(arrPair)\n        }\n\n        for (const pair of pairs) {\n          this.append(pair[0], pair[1])\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          this.append(key, init[key])\n        }\n      }\n    } else\n      throw new TypeError('Provided initializer must be an object')\n  }\n\n  get (name) {\n    name = `${name}`\n    validateName(name)\n    const key = find(this[MAP], name)\n    if (key === undefined)\n      return null\n\n    return this[MAP][key].join(', ')\n  }\n\n  forEach (callback, thisArg = undefined) {\n    let pairs = getHeaders(this)\n    for (let i = 0; i < pairs.length; i++) {\n      const [name, value] = pairs[i]\n      callback.call(thisArg, value, name, this)\n      // refresh in case the callback added more headers\n      pairs = getHeaders(this)\n    }\n  }\n\n  set (name, value) {\n    name = `${name}`\n    value = `${value}`\n    validateName(name)\n    validateValue(value)\n    const key = find(this[MAP], name)\n    this[MAP][key !== undefined ? key : name] = [value]\n  }\n\n  append (name, value) {\n    name = `${name}`\n    value = `${value}`\n    validateName(name)\n    validateValue(value)\n    const key = find(this[MAP], name)\n    if (key !== undefined)\n      this[MAP][key].push(value)\n    else\n      this[MAP][name] = [value]\n  }\n\n  has (name) {\n    name = `${name}`\n    validateName(name)\n    return find(this[MAP], name) !== undefined\n  }\n\n  delete (name) {\n    name = `${name}`\n    validateName(name)\n    const key = find(this[MAP], name)\n    if (key !== undefined)\n      delete this[MAP][key]\n  }\n\n  raw () {\n    return this[MAP]\n  }\n\n  keys () {\n    return new HeadersIterator(this, 'key')\n  }\n\n  values () {\n    return new HeadersIterator(this, 'value')\n  }\n\n  [Symbol.iterator]() {\n    return new HeadersIterator(this, 'key+value')\n  }\n\n  entries () {\n    return new HeadersIterator(this, 'key+value')\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Headers'\n  }\n\n  static exportNodeCompatibleHeaders (headers) {\n    const obj = Object.assign(Object.create(null), headers[MAP])\n\n    // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n    const hostHeaderKey = find(headers[MAP], 'Host')\n    if (hostHeaderKey !== undefined)\n      obj[hostHeaderKey] = obj[hostHeaderKey][0]\n\n    return obj\n  }\n\n  static createHeadersLenient (obj) {\n    const headers = new Headers()\n    for (const name of Object.keys(obj)) {\n      if (invalidTokenRegex.test(name))\n        continue\n\n      if (Array.isArray(obj[name])) {\n        for (const val of obj[name]) {\n          if (invalidHeaderCharRegex.test(val))\n            continue\n\n          if (headers[MAP][name] === undefined)\n            headers[MAP][name] = [val]\n          else\n            headers[MAP][name].push(val)\n        }\n      } else if (!invalidHeaderCharRegex.test(obj[name]))\n        headers[MAP][name] = [obj[name]]\n    }\n    return headers\n  }\n}\n\nObject.defineProperties(Headers.prototype, {\n  get: { enumerable: true },\n  forEach: { enumerable: true },\n  set: { enumerable: true },\n  append: { enumerable: true },\n  has: { enumerable: true },\n  delete: { enumerable: true },\n  keys: { enumerable: true },\n  values: { enumerable: true },\n  entries: { enumerable: true },\n})\n\nconst getHeaders = (headers, kind = 'key+value') =>\n  Object.keys(headers[MAP]).sort().map(\n    kind === 'key' ? k => k.toLowerCase()\n    : kind === 'value' ? k => headers[MAP][k].join(', ')\n    : k => [k.toLowerCase(), headers[MAP][k].join(', ')]\n  )\n\nconst INTERNAL = Symbol('internal')\n\nclass HeadersIterator {\n  constructor (target, kind) {\n    this[INTERNAL] = {\n      target,\n      kind,\n      index: 0,\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'HeadersIterator'\n  }\n\n  next () {\n    /* istanbul ignore if: should be impossible */\n    if (!this || Object.getPrototypeOf(this) !== HeadersIterator.prototype)\n      throw new TypeError('Value of `this` is not a HeadersIterator')\n\n    const { target, kind, index } = this[INTERNAL]\n    const values = getHeaders(target, kind)\n    const len = values.length\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true,\n      }\n    }\n\n    this[INTERNAL].index++\n\n    return { value: values[index], done: false }\n  }\n}\n\n// manually extend because 'extends' requires a ctor\nObject.setPrototypeOf(HeadersIterator.prototype,\n  Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())))\n\nmodule.exports = Headers\n"],"mappings":"AAAA;;AACA,MAAMA,iBAAiB,GAAG,+BAA1B;AACA,MAAMC,sBAAsB,GAAG,yBAA/B;;AAEA,MAAMC,YAAY,GAAGC,IAAI,IAAI;EAC3BA,IAAI,GAAI,GAAEA,IAAK,EAAf;EACA,IAAIH,iBAAiB,CAACI,IAAlB,CAAuBD,IAAvB,KAAgCA,IAAI,KAAK,EAA7C,EACE,MAAM,IAAIE,SAAJ,CAAe,GAAEF,IAAK,kCAAtB,CAAN;AACH,CAJD;;AAMA,MAAMG,aAAa,GAAGC,KAAK,IAAI;EAC7BA,KAAK,GAAI,GAAEA,KAAM,EAAjB;EACA,IAAIN,sBAAsB,CAACG,IAAvB,CAA4BG,KAA5B,CAAJ,EACE,MAAM,IAAIF,SAAJ,CAAe,GAAEE,KAAM,mCAAvB,CAAN;AACH,CAJD;;AAMA,MAAMC,IAAI,GAAG,CAACC,GAAD,EAAMN,IAAN,KAAe;EAC1BA,IAAI,GAAGA,IAAI,CAACO,WAAL,EAAP;;EACA,KAAK,MAAMC,GAAX,IAAkBF,GAAlB,EAAuB;IACrB,IAAIE,GAAG,CAACD,WAAJ,OAAsBP,IAA1B,EACE,OAAOQ,GAAP;EACH;;EACD,OAAOC,SAAP;AACD,CAPD;;AASA,MAAMC,GAAG,GAAGC,MAAM,CAAC,KAAD,CAAlB;;AACA,MAAMC,OAAN,CAAc;EACZC,WAAW,GAAoB;IAAA,IAAlBC,IAAkB,uEAAXL,SAAW;IAC7B,KAAKC,GAAL,IAAYK,MAAM,CAACC,MAAP,CAAc,IAAd,CAAZ;;IACA,IAAIF,IAAI,YAAYF,OAApB,EAA6B;MAC3B,MAAMK,UAAU,GAAGH,IAAI,CAACI,GAAL,EAAnB;MACA,MAAMC,WAAW,GAAGJ,MAAM,CAACK,IAAP,CAAYH,UAAZ,CAApB;;MACA,KAAK,MAAMI,UAAX,IAAyBF,WAAzB,EAAsC;QACpC,KAAK,MAAMf,KAAX,IAAoBa,UAAU,CAACI,UAAD,CAA9B,EAA4C;UAC1C,KAAKC,MAAL,CAAYD,UAAZ,EAAwBjB,KAAxB;QACD;MACF;;MACD;IACD,CAX4B,CAa7B;;;IACA,IAAIU,IAAI,KAAKL,SAAT,IAAsBK,IAAI,KAAK,IAAnC,EACE;;IAEF,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;MAC5B,MAAMS,MAAM,GAAGT,IAAI,CAACH,MAAM,CAACa,QAAR,CAAnB;;MACA,IAAID,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKd,SAAlC,EAA6C;QAC3C,IAAI,OAAOc,MAAP,KAAkB,UAAtB,EACE,MAAM,IAAIrB,SAAJ,CAAc,+BAAd,CAAN,CAFyC,CAI3C;QACA;;QACA,MAAMuB,KAAK,GAAG,EAAd;;QACA,KAAK,MAAMC,IAAX,IAAmBZ,IAAnB,EAAyB;UACvB,IAAI,OAAOY,IAAP,KAAgB,QAAhB,IACA,OAAOA,IAAI,CAACf,MAAM,CAACa,QAAR,CAAX,KAAiC,UADrC,EAEE,MAAM,IAAItB,SAAJ,CAAc,mCAAd,CAAN;UACF,MAAMyB,OAAO,GAAGC,KAAK,CAACC,IAAN,CAAWH,IAAX,CAAhB;UACA,IAAIC,OAAO,CAACG,MAAR,KAAmB,CAAvB,EACE,MAAM,IAAI5B,SAAJ,CAAc,6CAAd,CAAN;UACFuB,KAAK,CAACM,IAAN,CAAWJ,OAAX;QACD;;QAED,KAAK,MAAMD,IAAX,IAAmBD,KAAnB,EAA0B;UACxB,KAAKH,MAAL,CAAYI,IAAI,CAAC,CAAD,CAAhB,EAAqBA,IAAI,CAAC,CAAD,CAAzB;QACD;MACF,CApBD,MAoBO;QACL;QACA,KAAK,MAAMlB,GAAX,IAAkBO,MAAM,CAACK,IAAP,CAAYN,IAAZ,CAAlB,EAAqC;UACnC,KAAKQ,MAAL,CAAYd,GAAZ,EAAiBM,IAAI,CAACN,GAAD,CAArB;QACD;MACF;IACF,CA5BD,MA6BE,MAAM,IAAIN,SAAJ,CAAc,wCAAd,CAAN;EACH;;EAED8B,GAAG,CAAEhC,IAAF,EAAQ;IACTA,IAAI,GAAI,GAAEA,IAAK,EAAf;IACAD,YAAY,CAACC,IAAD,CAAZ;IACA,MAAMQ,GAAG,GAAGH,IAAI,CAAC,KAAKK,GAAL,CAAD,EAAYV,IAAZ,CAAhB;IACA,IAAIQ,GAAG,KAAKC,SAAZ,EACE,OAAO,IAAP;IAEF,OAAO,KAAKC,GAAL,EAAUF,GAAV,EAAeyB,IAAf,CAAoB,IAApB,CAAP;EACD;;EAEDC,OAAO,CAAEC,QAAF,EAAiC;IAAA,IAArBC,OAAqB,uEAAX3B,SAAW;IACtC,IAAIgB,KAAK,GAAGY,UAAU,CAAC,IAAD,CAAtB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,KAAK,CAACK,MAA1B,EAAkCQ,CAAC,EAAnC,EAAuC;MACrC,MAAM,CAACtC,IAAD,EAAOI,KAAP,IAAgBqB,KAAK,CAACa,CAAD,CAA3B;MACAH,QAAQ,CAACI,IAAT,CAAcH,OAAd,EAAuBhC,KAAvB,EAA8BJ,IAA9B,EAAoC,IAApC,EAFqC,CAGrC;;MACAyB,KAAK,GAAGY,UAAU,CAAC,IAAD,CAAlB;IACD;EACF;;EAEDG,GAAG,CAAExC,IAAF,EAAQI,KAAR,EAAe;IAChBJ,IAAI,GAAI,GAAEA,IAAK,EAAf;IACAI,KAAK,GAAI,GAAEA,KAAM,EAAjB;IACAL,YAAY,CAACC,IAAD,CAAZ;IACAG,aAAa,CAACC,KAAD,CAAb;IACA,MAAMI,GAAG,GAAGH,IAAI,CAAC,KAAKK,GAAL,CAAD,EAAYV,IAAZ,CAAhB;IACA,KAAKU,GAAL,EAAUF,GAAG,KAAKC,SAAR,GAAoBD,GAApB,GAA0BR,IAApC,IAA4C,CAACI,KAAD,CAA5C;EACD;;EAEDkB,MAAM,CAAEtB,IAAF,EAAQI,KAAR,EAAe;IACnBJ,IAAI,GAAI,GAAEA,IAAK,EAAf;IACAI,KAAK,GAAI,GAAEA,KAAM,EAAjB;IACAL,YAAY,CAACC,IAAD,CAAZ;IACAG,aAAa,CAACC,KAAD,CAAb;IACA,MAAMI,GAAG,GAAGH,IAAI,CAAC,KAAKK,GAAL,CAAD,EAAYV,IAAZ,CAAhB;IACA,IAAIQ,GAAG,KAAKC,SAAZ,EACE,KAAKC,GAAL,EAAUF,GAAV,EAAeuB,IAAf,CAAoB3B,KAApB,EADF,KAGE,KAAKM,GAAL,EAAUV,IAAV,IAAkB,CAACI,KAAD,CAAlB;EACH;;EAEDqC,GAAG,CAAEzC,IAAF,EAAQ;IACTA,IAAI,GAAI,GAAEA,IAAK,EAAf;IACAD,YAAY,CAACC,IAAD,CAAZ;IACA,OAAOK,IAAI,CAAC,KAAKK,GAAL,CAAD,EAAYV,IAAZ,CAAJ,KAA0BS,SAAjC;EACD;;EAEDiC,MAAM,CAAE1C,IAAF,EAAQ;IACZA,IAAI,GAAI,GAAEA,IAAK,EAAf;IACAD,YAAY,CAACC,IAAD,CAAZ;IACA,MAAMQ,GAAG,GAAGH,IAAI,CAAC,KAAKK,GAAL,CAAD,EAAYV,IAAZ,CAAhB;IACA,IAAIQ,GAAG,KAAKC,SAAZ,EACE,OAAO,KAAKC,GAAL,EAAUF,GAAV,CAAP;EACH;;EAEDU,GAAG,GAAI;IACL,OAAO,KAAKR,GAAL,CAAP;EACD;;EAEDU,IAAI,GAAI;IACN,OAAO,IAAIuB,eAAJ,CAAoB,IAApB,EAA0B,KAA1B,CAAP;EACD;;EAEDC,MAAM,GAAI;IACR,OAAO,IAAID,eAAJ,CAAoB,IAApB,EAA0B,OAA1B,CAAP;EACD;;EAEe,CAAfhC,MAAM,CAACa,QAAQ,IAAI;IAClB,OAAO,IAAImB,eAAJ,CAAoB,IAApB,EAA0B,WAA1B,CAAP;EACD;;EAEDE,OAAO,GAAI;IACT,OAAO,IAAIF,eAAJ,CAAoB,IAApB,EAA0B,WAA1B,CAAP;EACD;;EAEsB,KAAlBhC,MAAM,CAACmC,WAAW,IAAK;IAC1B,OAAO,SAAP;EACD;;EAEiC,OAA3BC,2BAA2B,CAAEC,OAAF,EAAW;IAC3C,MAAMC,GAAG,GAAGlC,MAAM,CAACmC,MAAP,CAAcnC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd,EAAmCgC,OAAO,CAACtC,GAAD,CAA1C,CAAZ,CAD2C,CAG3C;IACA;;IACA,MAAMyC,aAAa,GAAG9C,IAAI,CAAC2C,OAAO,CAACtC,GAAD,CAAR,EAAe,MAAf,CAA1B;IACA,IAAIyC,aAAa,KAAK1C,SAAtB,EACEwC,GAAG,CAACE,aAAD,CAAH,GAAqBF,GAAG,CAACE,aAAD,CAAH,CAAmB,CAAnB,CAArB;IAEF,OAAOF,GAAP;EACD;;EAE0B,OAApBG,oBAAoB,CAAEH,GAAF,EAAO;IAChC,MAAMD,OAAO,GAAG,IAAIpC,OAAJ,EAAhB;;IACA,KAAK,MAAMZ,IAAX,IAAmBe,MAAM,CAACK,IAAP,CAAY6B,GAAZ,CAAnB,EAAqC;MACnC,IAAIpD,iBAAiB,CAACI,IAAlB,CAAuBD,IAAvB,CAAJ,EACE;;MAEF,IAAI4B,KAAK,CAACyB,OAAN,CAAcJ,GAAG,CAACjD,IAAD,CAAjB,CAAJ,EAA8B;QAC5B,KAAK,MAAMsD,GAAX,IAAkBL,GAAG,CAACjD,IAAD,CAArB,EAA6B;UAC3B,IAAIF,sBAAsB,CAACG,IAAvB,CAA4BqD,GAA5B,CAAJ,EACE;UAEF,IAAIN,OAAO,CAACtC,GAAD,CAAP,CAAaV,IAAb,MAAuBS,SAA3B,EACEuC,OAAO,CAACtC,GAAD,CAAP,CAAaV,IAAb,IAAqB,CAACsD,GAAD,CAArB,CADF,KAGEN,OAAO,CAACtC,GAAD,CAAP,CAAaV,IAAb,EAAmB+B,IAAnB,CAAwBuB,GAAxB;QACH;MACF,CAVD,MAUO,IAAI,CAACxD,sBAAsB,CAACG,IAAvB,CAA4BgD,GAAG,CAACjD,IAAD,CAA/B,CAAL,EACLgD,OAAO,CAACtC,GAAD,CAAP,CAAaV,IAAb,IAAqB,CAACiD,GAAG,CAACjD,IAAD,CAAJ,CAArB;IACH;;IACD,OAAOgD,OAAP;EACD;;AAjKW;;AAoKdjC,MAAM,CAACwC,gBAAP,CAAwB3C,OAAO,CAAC4C,SAAhC,EAA2C;EACzCxB,GAAG,EAAE;IAAEyB,UAAU,EAAE;EAAd,CADoC;EAEzCvB,OAAO,EAAE;IAAEuB,UAAU,EAAE;EAAd,CAFgC;EAGzCjB,GAAG,EAAE;IAAEiB,UAAU,EAAE;EAAd,CAHoC;EAIzCnC,MAAM,EAAE;IAAEmC,UAAU,EAAE;EAAd,CAJiC;EAKzChB,GAAG,EAAE;IAAEgB,UAAU,EAAE;EAAd,CALoC;EAMzCf,MAAM,EAAE;IAAEe,UAAU,EAAE;EAAd,CANiC;EAOzCrC,IAAI,EAAE;IAAEqC,UAAU,EAAE;EAAd,CAPmC;EAQzCb,MAAM,EAAE;IAAEa,UAAU,EAAE;EAAd,CARiC;EASzCZ,OAAO,EAAE;IAAEY,UAAU,EAAE;EAAd;AATgC,CAA3C;;AAYA,MAAMpB,UAAU,GAAG,UAACW,OAAD;EAAA,IAAUU,IAAV,uEAAiB,WAAjB;EAAA,OACjB3C,MAAM,CAACK,IAAP,CAAY4B,OAAO,CAACtC,GAAD,CAAnB,EAA0BiD,IAA1B,GAAiCrD,GAAjC,CACEoD,IAAI,KAAK,KAAT,GAAiBE,CAAC,IAAIA,CAAC,CAACrD,WAAF,EAAtB,GACEmD,IAAI,KAAK,OAAT,GAAmBE,CAAC,IAAIZ,OAAO,CAACtC,GAAD,CAAP,CAAakD,CAAb,EAAgB3B,IAAhB,CAAqB,IAArB,CAAxB,GACA2B,CAAC,IAAI,CAACA,CAAC,CAACrD,WAAF,EAAD,EAAkByC,OAAO,CAACtC,GAAD,CAAP,CAAakD,CAAb,EAAgB3B,IAAhB,CAAqB,IAArB,CAAlB,CAHT,CADiB;AAAA,CAAnB;;AAOA,MAAM4B,QAAQ,GAAGlD,MAAM,CAAC,UAAD,CAAvB;;AAEA,MAAMgC,eAAN,CAAsB;EACpB9B,WAAW,CAAEiD,MAAF,EAAUJ,IAAV,EAAgB;IACzB,KAAKG,QAAL,IAAiB;MACfC,MADe;MAEfJ,IAFe;MAGfK,KAAK,EAAE;IAHQ,CAAjB;EAKD;;EAEsB,KAAlBpD,MAAM,CAACmC,WAAW,IAAK;IAC1B,OAAO,iBAAP;EACD;;EAEDkB,IAAI,GAAI;IACN;IACA,IAAI,CAAC,IAAD,IAASjD,MAAM,CAACkD,cAAP,CAAsB,IAAtB,MAAgCtB,eAAe,CAACa,SAA7D,EACE,MAAM,IAAItD,SAAJ,CAAc,0CAAd,CAAN;IAEF,MAAM;MAAE4D,MAAF;MAAUJ,IAAV;MAAgBK;IAAhB,IAA0B,KAAKF,QAAL,CAAhC;IACA,MAAMjB,MAAM,GAAGP,UAAU,CAACyB,MAAD,EAASJ,IAAT,CAAzB;IACA,MAAMQ,GAAG,GAAGtB,MAAM,CAACd,MAAnB;;IACA,IAAIiC,KAAK,IAAIG,GAAb,EAAkB;MAChB,OAAO;QACL9D,KAAK,EAAEK,SADF;QAEL0D,IAAI,EAAE;MAFD,CAAP;IAID;;IAED,KAAKN,QAAL,EAAeE,KAAf;IAEA,OAAO;MAAE3D,KAAK,EAAEwC,MAAM,CAACmB,KAAD,CAAf;MAAwBI,IAAI,EAAE;IAA9B,CAAP;EACD;;AA/BmB,C,CAkCtB;;;AACApD,MAAM,CAACqD,cAAP,CAAsBzB,eAAe,CAACa,SAAtC,EACEzC,MAAM,CAACkD,cAAP,CAAsBlD,MAAM,CAACkD,cAAP,CAAsB,GAAGtD,MAAM,CAACa,QAAV,GAAtB,CAAtB,CADF;AAGA6C,MAAM,CAACC,OAAP,GAAiB1D,OAAjB"},"metadata":{},"sourceType":"script"}