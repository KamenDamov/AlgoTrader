{"ast":null,"code":"/*!\r\n * type-is\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n'use strict';\n/**\r\n * Module dependencies.\r\n * @private\r\n */\n\nvar typer = require('media-typer');\n\nvar mime = require('mime-types');\n/**\r\n * Module exports.\r\n * @public\r\n */\n\n\nmodule.exports = typeofrequest;\nmodule.exports.is = typeis;\nmodule.exports.hasBody = hasbody;\nmodule.exports.normalize = normalize;\nmodule.exports.match = mimeMatch;\n/**\r\n * Compare a `value` content-type with `types`.\r\n * Each `type` can be an extension like `html`,\r\n * a special shortcut like `multipart` or `urlencoded`,\r\n * or a mime type.\r\n *\r\n * If no types match, `false` is returned.\r\n * Otherwise, the first `type` that matches is returned.\r\n *\r\n * @param {String} value\r\n * @param {Array} types\r\n * @public\r\n */\n\nfunction typeis(value, types_) {\n  var i;\n  var types = types_; // remove parameters and normalize\n\n  var val = tryNormalizeType(value); // no type or invalid\n\n  if (!val) {\n    return false;\n  } // support flattened arguments\n\n\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length - 1);\n\n    for (i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1];\n    }\n  } // no types, return the content type\n\n\n  if (!types || !types.length) {\n    return val;\n  }\n\n  var type;\n\n  for (i = 0; i < types.length; i++) {\n    if (mimeMatch(normalize(type = types[i]), val)) {\n      return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;\n    }\n  } // no matches\n\n\n  return false;\n}\n/**\r\n * Check if a request has a request body.\r\n * A request with a body __must__ either have `transfer-encoding`\r\n * or `content-length` headers set.\r\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\r\n *\r\n * @param {Object} request\r\n * @return {Boolean}\r\n * @public\r\n */\n\n\nfunction hasbody(req) {\n  return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);\n}\n/**\r\n * Check if the incoming request contains the \"Content-Type\"\r\n * header field, and it contains any of the give mime `type`s.\r\n * If there is no request body, `null` is returned.\r\n * If there is no content type, `false` is returned.\r\n * Otherwise, it returns the first `type` that matches.\r\n *\r\n * Examples:\r\n *\r\n *     // With Content-Type: text/html; charset=utf-8\r\n *     this.is('html'); // => 'html'\r\n *     this.is('text/html'); // => 'text/html'\r\n *     this.is('text/*', 'application/json'); // => 'text/html'\r\n *\r\n *     // When Content-Type is application/json\r\n *     this.is('json', 'urlencoded'); // => 'json'\r\n *     this.is('application/json'); // => 'application/json'\r\n *     this.is('html', 'application/*'); // => 'application/json'\r\n *\r\n *     this.is('html'); // => false\r\n *\r\n * @param {String|Array} types...\r\n * @return {String|false|null}\r\n * @public\r\n */\n\n\nfunction typeofrequest(req, types_) {\n  var types = types_; // no body\n\n  if (!hasbody(req)) {\n    return null;\n  } // support flattened arguments\n\n\n  if (arguments.length > 2) {\n    types = new Array(arguments.length - 1);\n\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1];\n    }\n  } // request content type\n\n\n  var value = req.headers['content-type'];\n  return typeis(value, types);\n}\n/**\r\n * Normalize a mime type.\r\n * If it's a shorthand, expand it to a valid mime type.\r\n *\r\n * In general, you probably want:\r\n *\r\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\r\n *\r\n * Then use the appropriate body parsers.\r\n * These three are the most common request body types\r\n * and are thus ensured to work.\r\n *\r\n * @param {String} type\r\n * @private\r\n */\n\n\nfunction normalize(type) {\n  if (typeof type !== 'string') {\n    // invalid type\n    return false;\n  }\n\n  switch (type) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded';\n\n    case 'multipart':\n      return 'multipart/*';\n  }\n\n  if (type[0] === '+') {\n    // \"+json\" -> \"*/*+json\" expando\n    return '*/*' + type;\n  }\n\n  return type.indexOf('/') === -1 ? mime.lookup(type) : type;\n}\n/**\r\n * Check if `expected` mime type\r\n * matches `actual` mime type with\r\n * wildcard and +suffix support.\r\n *\r\n * @param {String} expected\r\n * @param {String} actual\r\n * @return {Boolean}\r\n * @private\r\n */\n\n\nfunction mimeMatch(expected, actual) {\n  // invalid type\n  if (expected === false) {\n    return false;\n  } // split types\n\n\n  var actualParts = actual.split('/');\n  var expectedParts = expected.split('/'); // invalid format\n\n  if (actualParts.length !== 2 || expectedParts.length !== 2) {\n    return false;\n  } // validate type\n\n\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {\n    return false;\n  } // validate suffix wildcard\n\n\n  if (expectedParts[1].substr(0, 2) === '*+') {\n    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);\n  } // validate subtype\n\n\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {\n    return false;\n  }\n\n  return true;\n}\n/**\r\n * Normalize a type and remove parameters.\r\n *\r\n * @param {string} value\r\n * @return {string}\r\n * @private\r\n */\n\n\nfunction normalizeType(value) {\n  // parse the type\n  var type = typer.parse(value); // remove the parameters\n\n  type.parameters = undefined; // reformat it\n\n  return typer.format(type);\n}\n/**\r\n * Try to normalize a type and remove parameters.\r\n *\r\n * @param {string} value\r\n * @return {string}\r\n * @private\r\n */\n\n\nfunction tryNormalizeType(value) {\n  if (!value) {\n    return null;\n  }\n\n  try {\n    return normalizeType(value);\n  } catch (err) {\n    return null;\n  }\n}","map":{"version":3,"names":["typer","require","mime","module","exports","typeofrequest","is","typeis","hasBody","hasbody","normalize","match","mimeMatch","value","types_","i","types","val","tryNormalizeType","Array","isArray","arguments","length","type","indexOf","req","headers","undefined","isNaN","lookup","expected","actual","actualParts","split","expectedParts","substr","normalizeType","parse","parameters","format","err"],"sources":["C:/Users/Kamen/ML/AlgoTrader/my-app/node_modules/type-is/index.js"],"sourcesContent":["/*!\r\n * type-is\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar typer = require('media-typer')\r\nvar mime = require('mime-types')\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nmodule.exports = typeofrequest\r\nmodule.exports.is = typeis\r\nmodule.exports.hasBody = hasbody\r\nmodule.exports.normalize = normalize\r\nmodule.exports.match = mimeMatch\r\n\r\n/**\r\n * Compare a `value` content-type with `types`.\r\n * Each `type` can be an extension like `html`,\r\n * a special shortcut like `multipart` or `urlencoded`,\r\n * or a mime type.\r\n *\r\n * If no types match, `false` is returned.\r\n * Otherwise, the first `type` that matches is returned.\r\n *\r\n * @param {String} value\r\n * @param {Array} types\r\n * @public\r\n */\r\n\r\nfunction typeis (value, types_) {\r\n  var i\r\n  var types = types_\r\n\r\n  // remove parameters and normalize\r\n  var val = tryNormalizeType(value)\r\n\r\n  // no type or invalid\r\n  if (!val) {\r\n    return false\r\n  }\r\n\r\n  // support flattened arguments\r\n  if (types && !Array.isArray(types)) {\r\n    types = new Array(arguments.length - 1)\r\n    for (i = 0; i < types.length; i++) {\r\n      types[i] = arguments[i + 1]\r\n    }\r\n  }\r\n\r\n  // no types, return the content type\r\n  if (!types || !types.length) {\r\n    return val\r\n  }\r\n\r\n  var type\r\n  for (i = 0; i < types.length; i++) {\r\n    if (mimeMatch(normalize(type = types[i]), val)) {\r\n      return type[0] === '+' || type.indexOf('*') !== -1\r\n        ? val\r\n        : type\r\n    }\r\n  }\r\n\r\n  // no matches\r\n  return false\r\n}\r\n\r\n/**\r\n * Check if a request has a request body.\r\n * A request with a body __must__ either have `transfer-encoding`\r\n * or `content-length` headers set.\r\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\r\n *\r\n * @param {Object} request\r\n * @return {Boolean}\r\n * @public\r\n */\r\n\r\nfunction hasbody (req) {\r\n  return req.headers['transfer-encoding'] !== undefined ||\r\n    !isNaN(req.headers['content-length'])\r\n}\r\n\r\n/**\r\n * Check if the incoming request contains the \"Content-Type\"\r\n * header field, and it contains any of the give mime `type`s.\r\n * If there is no request body, `null` is returned.\r\n * If there is no content type, `false` is returned.\r\n * Otherwise, it returns the first `type` that matches.\r\n *\r\n * Examples:\r\n *\r\n *     // With Content-Type: text/html; charset=utf-8\r\n *     this.is('html'); // => 'html'\r\n *     this.is('text/html'); // => 'text/html'\r\n *     this.is('text/*', 'application/json'); // => 'text/html'\r\n *\r\n *     // When Content-Type is application/json\r\n *     this.is('json', 'urlencoded'); // => 'json'\r\n *     this.is('application/json'); // => 'application/json'\r\n *     this.is('html', 'application/*'); // => 'application/json'\r\n *\r\n *     this.is('html'); // => false\r\n *\r\n * @param {String|Array} types...\r\n * @return {String|false|null}\r\n * @public\r\n */\r\n\r\nfunction typeofrequest (req, types_) {\r\n  var types = types_\r\n\r\n  // no body\r\n  if (!hasbody(req)) {\r\n    return null\r\n  }\r\n\r\n  // support flattened arguments\r\n  if (arguments.length > 2) {\r\n    types = new Array(arguments.length - 1)\r\n    for (var i = 0; i < types.length; i++) {\r\n      types[i] = arguments[i + 1]\r\n    }\r\n  }\r\n\r\n  // request content type\r\n  var value = req.headers['content-type']\r\n\r\n  return typeis(value, types)\r\n}\r\n\r\n/**\r\n * Normalize a mime type.\r\n * If it's a shorthand, expand it to a valid mime type.\r\n *\r\n * In general, you probably want:\r\n *\r\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\r\n *\r\n * Then use the appropriate body parsers.\r\n * These three are the most common request body types\r\n * and are thus ensured to work.\r\n *\r\n * @param {String} type\r\n * @private\r\n */\r\n\r\nfunction normalize (type) {\r\n  if (typeof type !== 'string') {\r\n    // invalid type\r\n    return false\r\n  }\r\n\r\n  switch (type) {\r\n    case 'urlencoded':\r\n      return 'application/x-www-form-urlencoded'\r\n    case 'multipart':\r\n      return 'multipart/*'\r\n  }\r\n\r\n  if (type[0] === '+') {\r\n    // \"+json\" -> \"*/*+json\" expando\r\n    return '*/*' + type\r\n  }\r\n\r\n  return type.indexOf('/') === -1\r\n    ? mime.lookup(type)\r\n    : type\r\n}\r\n\r\n/**\r\n * Check if `expected` mime type\r\n * matches `actual` mime type with\r\n * wildcard and +suffix support.\r\n *\r\n * @param {String} expected\r\n * @param {String} actual\r\n * @return {Boolean}\r\n * @private\r\n */\r\n\r\nfunction mimeMatch (expected, actual) {\r\n  // invalid type\r\n  if (expected === false) {\r\n    return false\r\n  }\r\n\r\n  // split types\r\n  var actualParts = actual.split('/')\r\n  var expectedParts = expected.split('/')\r\n\r\n  // invalid format\r\n  if (actualParts.length !== 2 || expectedParts.length !== 2) {\r\n    return false\r\n  }\r\n\r\n  // validate type\r\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {\r\n    return false\r\n  }\r\n\r\n  // validate suffix wildcard\r\n  if (expectedParts[1].substr(0, 2) === '*+') {\r\n    return expectedParts[1].length <= actualParts[1].length + 1 &&\r\n      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)\r\n  }\r\n\r\n  // validate subtype\r\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {\r\n    return false\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * Normalize a type and remove parameters.\r\n *\r\n * @param {string} value\r\n * @return {string}\r\n * @private\r\n */\r\n\r\nfunction normalizeType (value) {\r\n  // parse the type\r\n  var type = typer.parse(value)\r\n\r\n  // remove the parameters\r\n  type.parameters = undefined\r\n\r\n  // reformat it\r\n  return typer.format(type)\r\n}\r\n\r\n/**\r\n * Try to normalize a type and remove parameters.\r\n *\r\n * @param {string} value\r\n * @return {string}\r\n * @private\r\n */\r\n\r\nfunction tryNormalizeType (value) {\r\n  if (!value) {\r\n    return null\r\n  }\r\n\r\n  try {\r\n    return normalizeType(value)\r\n  } catch (err) {\r\n    return null\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}