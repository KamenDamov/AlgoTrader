{"ast":null,"code":"'use strict';\n\nvar crypto = require('crypto');\nvar defaults = require('./defaults');\nfunction escapeElement(elementRepresentation) {\n  var escaped = elementRepresentation.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n  return '\"' + escaped + '\"';\n}\n\n// convert a JS array to a postgres array literal\n// uses comma separator so won't work for types like box that use\n// a different array separator.\nfunction arrayString(val) {\n  var result = '{';\n  for (var i = 0; i < val.length; i++) {\n    if (i > 0) {\n      result = result + ',';\n    }\n    if (val[i] === null || typeof val[i] === 'undefined') {\n      result = result + 'NULL';\n    } else if (Array.isArray(val[i])) {\n      result = result + arrayString(val[i]);\n    } else if (val[i] instanceof Buffer) {\n      result += '\\\\\\\\x' + val[i].toString('hex');\n    } else {\n      result += escapeElement(prepareValue(val[i]));\n    }\n  }\n  result = result + '}';\n  return result;\n}\n\n// converts values from javascript types\n// to their 'raw' counterparts for use as a postgres parameter\n// note: you can override this function to provide your own conversion mechanism\n// for complex types, etc...\nvar prepareValue = function prepareValue(val, seen) {\n  // null and undefined are both null for postgres\n  if (val == null) {\n    return null;\n  }\n  if (val instanceof Buffer) {\n    return val;\n  }\n  if (ArrayBuffer.isView(val)) {\n    var buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);\n    if (buf.length === val.byteLength) {\n      return buf;\n    }\n    return buf.slice(val.byteOffset, val.byteOffset + val.byteLength); // Node.js v4 does not support those Buffer.from params\n  }\n\n  if (val instanceof Date) {\n    if (defaults.parseInputDatesAsUTC) {\n      return dateToStringUTC(val);\n    } else {\n      return dateToString(val);\n    }\n  }\n  if (Array.isArray(val)) {\n    return arrayString(val);\n  }\n  if (typeof val === 'object') {\n    return prepareObject(val, seen);\n  }\n  return val.toString();\n};\nfunction prepareObject(val, seen) {\n  if (val && typeof val.toPostgres === 'function') {\n    seen = seen || [];\n    if (seen.indexOf(val) !== -1) {\n      throw new Error('circular reference detected while preparing \"' + val + '\" for query');\n    }\n    seen.push(val);\n    return prepareValue(val.toPostgres(prepareValue), seen);\n  }\n  return JSON.stringify(val);\n}\nfunction pad(number, digits) {\n  number = '' + number;\n  while (number.length < digits) {\n    number = '0' + number;\n  }\n  return number;\n}\nfunction dateToString(date) {\n  var offset = -date.getTimezoneOffset();\n  var year = date.getFullYear();\n  var isBCYear = year < 1;\n  if (isBCYear) year = Math.abs(year) + 1; // negative years are 1 off their BC representation\n\n  var ret = pad(year, 4) + '-' + pad(date.getMonth() + 1, 2) + '-' + pad(date.getDate(), 2) + 'T' + pad(date.getHours(), 2) + ':' + pad(date.getMinutes(), 2) + ':' + pad(date.getSeconds(), 2) + '.' + pad(date.getMilliseconds(), 3);\n  if (offset < 0) {\n    ret += '-';\n    offset *= -1;\n  } else {\n    ret += '+';\n  }\n  ret += pad(Math.floor(offset / 60), 2) + ':' + pad(offset % 60, 2);\n  if (isBCYear) ret += ' BC';\n  return ret;\n}\nfunction dateToStringUTC(date) {\n  var year = date.getUTCFullYear();\n  var isBCYear = year < 1;\n  if (isBCYear) year = Math.abs(year) + 1; // negative years are 1 off their BC representation\n\n  var ret = pad(year, 4) + '-' + pad(date.getUTCMonth() + 1, 2) + '-' + pad(date.getUTCDate(), 2) + 'T' + pad(date.getUTCHours(), 2) + ':' + pad(date.getUTCMinutes(), 2) + ':' + pad(date.getUTCSeconds(), 2) + '.' + pad(date.getUTCMilliseconds(), 3);\n  ret += '+00:00';\n  if (isBCYear) ret += ' BC';\n  return ret;\n}\nfunction normalizeQueryConfig(config, values, callback) {\n  // can take in strings or config objects\n  config = typeof config === 'string' ? {\n    text: config\n  } : config;\n  if (values) {\n    if (typeof values === 'function') {\n      config.callback = values;\n    } else {\n      config.values = values;\n    }\n  }\n  if (callback) {\n    config.callback = callback;\n  }\n  return config;\n}\nvar md5 = function md5(string) {\n  return crypto.createHash('md5').update(string, 'utf-8').digest('hex');\n};\n\n// See AuthenticationMD5Password at https://www.postgresql.org/docs/current/static/protocol-flow.html\nvar postgresMd5PasswordHash = function postgresMd5PasswordHash(user, password, salt) {\n  var inner = md5(password + user);\n  var outer = md5(Buffer.concat([Buffer.from(inner), salt]));\n  return 'md5' + outer;\n};\nmodule.exports = {\n  prepareValue: function prepareValueWrapper(value) {\n    // this ensures that extra arguments do not get passed into prepareValue\n    // by accident, eg: from calling values.map(utils.prepareValue)\n    return prepareValue(value);\n  },\n  normalizeQueryConfig: normalizeQueryConfig,\n  postgresMd5PasswordHash: postgresMd5PasswordHash,\n  md5: md5\n};","map":null,"metadata":{},"sourceType":"script"}