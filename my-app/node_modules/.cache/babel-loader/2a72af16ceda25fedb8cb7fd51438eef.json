{"ast":null,"code":"const CacheSemantics = require('http-cache-semantics');\n\nconst Negotiator = require('negotiator');\n\nconst ssri = require('ssri'); // HACK: negotiator lazy loads several of its own modules\n// as a micro optimization. we need to be sure that they're\n// in memory as soon as possible at startup so that we do\n// not try to lazy load them after the directory has been\n// retired during a self update of the npm CLI, we do this\n// by calling all of the methods that trigger a lazy load\n// on a fake instance.\n\n\nconst preloadNegotiator = new Negotiator({\n  headers: {}\n});\npreloadNegotiator.charsets();\npreloadNegotiator.encodings();\npreloadNegotiator.languages();\npreloadNegotiator.mediaTypes(); // options passed to http-cache-semantics constructor\n\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true\n}; // a fake empty response, used when only testing the\n// request for storability\n\nconst emptyResponse = {\n  status: 200,\n  headers: {}\n}; // returns a plain object representation of the Request\n\nconst requestObject = request => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {}\n  };\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n}; // returns a plain object representation of the Response\n\n\nconst responseObject = response => {\n  const _obj = {\n    status: response.status,\n    headers: {}\n  };\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n};\n\nclass CachePolicy {\n  constructor(_ref) {\n    let {\n      entry,\n      request,\n      response,\n      options\n    } = _ref;\n    this.entry = entry;\n    this.request = requestObject(request);\n    this.response = responseObject(response);\n    this.options = options;\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions);\n\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time;\n    }\n  } // static method to quickly determine if a request alone is storable\n\n\n  static storable(request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath) return false; // user explicitly asked not to cache\n\n    if (options.cache === 'no-store') return false; // we only cache GET and HEAD requests\n\n    if (!['GET', 'HEAD'].includes(request.method)) return false; // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions);\n    return policy.storable();\n  } // returns true if the policy satisfies the request\n\n\n  satisfies(request) {\n    const _req = requestObject(request);\n\n    if (this.request.headers.host !== _req.headers.host) return false;\n    const negotiatorA = new Negotiator(this.request);\n    const negotiatorB = new Negotiator(_req);\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) return false;\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) return false;\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) return false;\n    if (this.options.integrity) return ssri.parse(this.options.integrity).match(this.entry.integrity);\n    return true;\n  } // returns true if the request and response allow caching\n\n\n  storable() {\n    return this.policy.storable();\n  } // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n\n\n  get mustRevalidate() {\n    return !!this.policy._rescc['must-revalidate'];\n  } // returns true if the cached response requires revalidation\n  // for the given request\n\n\n  needsRevalidation(request) {\n    const _req = requestObject(request); // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n\n\n    _req.method = 'GET';\n    return !this.policy.satisfiesWithoutRevalidation(_req);\n  }\n\n  responseHeaders() {\n    return this.policy.responseHeaders();\n  } // returns a new object containing the appropriate headers\n  // to send a revalidation request\n\n\n  revalidationHeaders(request) {\n    const _req = requestObject(request);\n\n    return this.policy.revalidationHeaders(_req);\n  } // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n\n\n  revalidated(request, response) {\n    const _req = requestObject(request);\n\n    const _res = responseObject(response);\n\n    const policy = this.policy.revalidatedPolicy(_req, _res);\n    return !policy.modified;\n  }\n\n}\n\nmodule.exports = CachePolicy;","map":{"version":3,"names":["CacheSemantics","require","Negotiator","ssri","preloadNegotiator","headers","charsets","encodings","languages","mediaTypes","policyOptions","shared","ignoreCargoCult","emptyResponse","status","requestObject","request","_obj","method","url","forEach","value","key","responseObject","response","CachePolicy","constructor","entry","options","policy","_responseTime","metadata","time","storable","cachePath","cache","includes","satisfies","_req","host","negotiatorA","negotiatorB","JSON","stringify","integrity","parse","match","mustRevalidate","_rescc","needsRevalidation","satisfiesWithoutRevalidation","responseHeaders","revalidationHeaders","revalidated","_res","revalidatedPolicy","modified","module","exports"],"sources":["C:/Users/Kamen/ML/AlgoTrader/node_modules/make-fetch-happen/lib/cache/policy.js"],"sourcesContent":["const CacheSemantics = require('http-cache-semantics')\nconst Negotiator = require('negotiator')\nconst ssri = require('ssri')\n\n// HACK: negotiator lazy loads several of its own modules\n// as a micro optimization. we need to be sure that they're\n// in memory as soon as possible at startup so that we do\n// not try to lazy load them after the directory has been\n// retired during a self update of the npm CLI, we do this\n// by calling all of the methods that trigger a lazy load\n// on a fake instance.\nconst preloadNegotiator = new Negotiator({ headers: {} })\npreloadNegotiator.charsets()\npreloadNegotiator.encodings()\npreloadNegotiator.languages()\npreloadNegotiator.mediaTypes()\n\n// options passed to http-cache-semantics constructor\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true,\n}\n\n// a fake empty response, used when only testing the\n// request for storability\nconst emptyResponse = { status: 200, headers: {} }\n\n// returns a plain object representation of the Request\nconst requestObject = (request) => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {},\n  }\n\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\n// returns a plain object representation of the Response\nconst responseObject = (response) => {\n  const _obj = {\n    status: response.status,\n    headers: {},\n  }\n\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\nclass CachePolicy {\n  constructor ({ entry, request, response, options }) {\n    this.entry = entry\n    this.request = requestObject(request)\n    this.response = responseObject(response)\n    this.options = options\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions)\n\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time\n    }\n  }\n\n  // static method to quickly determine if a request alone is storable\n  static storable (request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath)\n      return false\n\n    // user explicitly asked not to cache\n    if (options.cache === 'no-store')\n      return false\n\n    // we only cache GET and HEAD requests\n    if (!['GET', 'HEAD'].includes(request.method))\n      return false\n\n    // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions)\n    return policy.storable()\n  }\n\n  // returns true if the policy satisfies the request\n  satisfies (request) {\n    const _req = requestObject(request)\n    if (this.request.headers.host !== _req.headers.host)\n      return false\n\n    const negotiatorA = new Negotiator(this.request)\n    const negotiatorB = new Negotiator(_req)\n\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes()))\n      return false\n\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages()))\n      return false\n\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings()))\n      return false\n\n    if (this.options.integrity)\n      return ssri.parse(this.options.integrity).match(this.entry.integrity)\n\n    return true\n  }\n\n  // returns true if the request and response allow caching\n  storable () {\n    return this.policy.storable()\n  }\n\n  // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n  get mustRevalidate () {\n    return !!this.policy._rescc['must-revalidate']\n  }\n\n  // returns true if the cached response requires revalidation\n  // for the given request\n  needsRevalidation (request) {\n    const _req = requestObject(request)\n    // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n    _req.method = 'GET'\n    return !this.policy.satisfiesWithoutRevalidation(_req)\n  }\n\n  responseHeaders () {\n    return this.policy.responseHeaders()\n  }\n\n  // returns a new object containing the appropriate headers\n  // to send a revalidation request\n  revalidationHeaders (request) {\n    const _req = requestObject(request)\n    return this.policy.revalidationHeaders(_req)\n  }\n\n  // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n  revalidated (request, response) {\n    const _req = requestObject(request)\n    const _res = responseObject(response)\n    const policy = this.policy.revalidatedPolicy(_req, _res)\n    return !policy.modified\n  }\n}\n\nmodule.exports = CachePolicy\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}